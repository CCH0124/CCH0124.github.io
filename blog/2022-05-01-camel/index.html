<!doctype html><html lang=en-us style=max-width:1000px;margin:auto><head><title>Kevin Blog</title><meta name=theme-color content><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta name=description content="Kevin learning"><meta name=author content="Kevin Chen"><meta name=generator content="aafu theme by Darshan in Hugo 0.83.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.15.2/css/all.css integrity=sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu crossorigin=anonymous><link rel=stylesheet href=https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css><link rel=stylesheet href="//fonts.googleapis.com/css?family=Didact+Gothic%7CRoboto:400%7CRoboto+Mono"><link rel=stylesheet href=/css/aafu_pinkish.css><link rel=stylesheet href=/css/aafu.css><script>var themeColor=document.querySelector("meta[name=theme-color]");window.onload=()=>{themeColor.content=getComputedStyle(document.body)["background-color"];let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")},window.onresize=()=>{let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")}</script></head><body class=container><main style="min-height:calc(100vh - 60px)"><div class="d-flex flex-row row p-2"><h3 class="main-menu mr-3"><a href=https://cch0124.github.io/>Home</a></h3><h3 class="main-menu mr-3"><a href=/blog>Blog</a></h3><h3 class="main-menu mr-3"><a href=/project>Project</a></h3><h3 class="main-menu mr-3"><a href=/life>Life</a></h3><h3 class="main-menu mr-3"><a href=/kubernetes>Kubernetes</a></h3><h3 class="main-menu mr-3"><a href=/code>Coding</a></h3></div><div class=mb-3><h1 class=top-h1 style=font-size:2.75em>Camel 概觀</h1><p class=mb-1>December 8, 2020</p><p>&mdash;</p></div><div class=content><p><code>Camel</code> 對於 Java 來說是一個整合函式庫，期提供 API 使你可以整合不同的來源數據，<code>Camel</code> 可以說是不同數據之間的膠水，從一個應用程式獲取數據，並透過管道傳輸到另一個應用程式，該過程可以轉換、變更。</p><p>當有資源需要從 A 到 B 或許 <code>Camel</code> 是一個好的整合工具，其場景可能是</p><ul><li>發送 Mail</li><li>地端資料送到雲端硬碟</li><li>從 AWS SQS 獲取訊息，再調用我們自己 API</li><li>XML 轉 CSV</li><li>從資料庫獲取資料</li><li>等等</li></ul><p><code>Camel</code> 有以下核心元件</p><ul><li>Camel Core<ul><li>包含 Camel APIs、Camel runtime engine、Camel 應用程式運行時管理的功能</li></ul></li><li>Component JARs<ul><li>每個組件擴展了 Camel 與第三方系統或 API 交互的功能</li></ul></li><li>Platform support JARs<ul><li>提供 Camel 在不同平台上運行的功能</li></ul></li></ul><p>下圖是 <code>Camel</code> 概念圖<figure><img src=/images/blog/camel/camel-concept.png width=auto height=auto></figure></p><p><code>Camel</code> 提供 <em>runtime engine</em>，他叫 <strong>Camel Context</strong>，負責運行 <code>Camel</code> 整合。</p><h2 id=camel-集成概念>Camel 集成概念</h2><h3 id=route>Route</h3><p>在 <code>Camel</code> 中，這些集成管道稱為 <strong>Routes</strong>。一個 <code>Route</code> 由一連串步驟組成。第一步要嘛<strong>接收</strong>或<strong>獲取</strong>數據，然後再透過後續步驟傳遞到 <code>Route</code> 的末尾。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>from<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;file:documents/invoices&#34;</span><span style=color:#f92672>)</span> <span style=color:#75715e>// 接收數據的路由
</span><span style=color:#75715e></span>  <span style=color:#f92672>.</span><span style=color:#a6e22e>to</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;file:documents/done&#34;</span><span style=color:#f92672>);</span> <span style=color:#75715e>// 最後結束的路由
</span></code></pre></div><p>定義 Route 可用 Java DSL 或 XML DSL。</p><h3 id=endpoint>Endpoint</h3><p>在寫 <code>Route</code> 時，經常需要與其它系統進行交互。<code>Endpoint</code> 是 <code>Camel</code> 與另一個系統交換資料的接口，Camel 可從 <code>Endpoint</code> 接收或是發送訊息。</p><p>以上述範例來看，Camel 接收來自 <code>file</code> <code>Endpoint</code> 的訊息，其讀取硬碟上的檔案。<em>在這過程中也許會因為需求而已某些方式進行處理轉換</em>。而 Camel 路由中的 <code>Endpoint</code> 由組件(Component) 組成。</p><h3 id=component>Component</h3><p>要讓 <code>Endpoint</code> 能夠作用，需使用組件(Component)。它是一個套件，允許你和外部系統交互，像是 mail、Dropbox 等。</p><p>藉由組件我們可以不必浪費時間在寫程式碼，只須找適合的組件來應用。而組件是可<em>重用</em>的，並且也可自行創建。</p><table><thead><tr><th>Component</th><th>Purpose</th><th>Endpoint URI</th></tr></thead><tbody><tr><td>File</td><td>read or write a file</td><td>file:</td></tr><tr><td>Direct</td><td>join your Camel routes together</td><td>direct:</td></tr><tr><td>HTTP</td><td>make an HTTP request</td><td>http:</td></tr></tbody></table><p>如果以 producer 和 consumer 角度來看，前者表示寫(硬碟寫檔、發送訊息)後者表示讀(硬碟讀檔、接收 API 請求)。</p><h3 id=processor>Processor</h3><p><code>Processor</code> 是 Camel 路由中另一個步驟。允許針對訊息運行一些自定義代碼。可以實現一些業務邏輯、調用另一個系統或 Java 的 API。</p><p><code>Processor</code> 是一個實現 Camel 中的 <code>Processor</code> 接口的一個 Java 類別。</p><h3 id=example>Example</h3><p>下面定義了三個路由的範例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>package</span> com.example.cch.cameldemo.route<span style=color:#f92672>;</span>

<span style=color:#f92672>import</span> org.apache.camel.builder.RouteBuilder<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> org.springframework.stereotype.Component<span style=color:#f92672>;</span>
<span style=color:#75715e>// 將 src-folder 目錄中的所有檔案移動到 des-folder 目錄
</span><span style=color:#75715e></span><span style=color:#a6e22e>@Component</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FileRouteBuilder</span> <span style=color:#66d9ef>extends</span> RouteBuilder <span style=color:#f92672>{</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>configure</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
        <span style=color:#75715e>// TODO Auto-generated method stub
</span><span style=color:#75715e></span>        from<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;file:&#34;</span><span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;src/test/src-folder/&#34;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;?noop=true&#34;</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>log</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Received...&#34;</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>to</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;file:&#34;</span><span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;src/test/des-folder/&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

</code></pre></div><p>Gradel 需要加以下的套件</p><pre><code>// https://mvnrepository.com/artifact/org.apache.camel.springboot/camel-core-starter
implementation group: 'org.apache.camel.springboot', name: 'camel-core-starter', version: '3.16.0'
	// https://mvnrepository.com/artifact/org.apache.camel.springboot/camel-file-starter
implementation group: 'org.apache.camel.springboot', name: 'camel-file-starter', version: '3.16.0'
</code></pre><h2 id=enterprise-integration-patterns>Enterprise Integration Patterns</h2><p><code>Enterprise Integration Patterns</code>(EIPs) 對於 Camel 來說是一個重要的模式。是 Camel 的基本組成部分，一個 <a href=https://www.enterpriseintegrationpatterns.com/patterns/messaging/PipesAndFilters.html>Pipes and Filters pattern</a> 在 Camel 中表示為 Route。</p><p>Camel 完整實現模式的列表資源 <a href=https://camel.apache.org/components/3.16.x/eips/enterprise-integration-patterns.html>Camel EIPs</a></p><h2 id=end-of-a-route>End of a route</h2><p>在 <code>Route</code> 結束時，<code>Camel</code> 會根據消息的屬性(Message Exchange Pattern, MEP) 做兩件事之一。</p><ul><li>Return the final output message back to the consumer<ul><li>Camel 將來自最終端點的輸出訊息返回給調用者，並完成路由</li></ul></li><li>Do nothing<ul><li>Exchange pattern 設置為 <code>InOnly</code>，就是消費者(consumer )從不期望從調用者那裡收到訊息。</li></ul></li></ul><p>上述的範例就是一個 <code>Do nothing</code> 的例子。</p><h2 id=messages-in-camel>Messages in Camel</h2><p>Camel 使用訊息模式(message model)處理數據。Camel 將 Route 中的數據視為訊息，有可能是以下</p><ul><li>Web 服務請求</li><li>硬碟中的檔案</li><li>從 JMS 佇列接收訊息</li></ul><p>在 Camel 中有一個 message 的 API 物件來表示一條訊息，會有 Body、Header 和屬性(可用來保存訊息關聯的值)，最後沿著 Route 往下傳遞。</p><h3 id=introducing-the-exchange>Introducing the Exchange</h3><p><code>Exchange</code> 只是當前在 Route 內發生的訊息或交互內容。</p><p><code>Exchange</code> 是在 Route 開始建立時建立的，也就是 <code>from</code>，會隨著訊息經過的 Route 而更新。而 <code>Exchange</code> 物件會保存當前的請求和響應訊息。</p><h3 id=message-contain->Message contain ?</h3><p>對於訊息的 Body 可以是 Java 物件、JSON 或是純文字等，對於 Camel 來說這個優勢非常的強大，我們可以省下轉換的程式碼。</p><table><thead><tr><th>Component</th><th>What it is</th></tr></thead><tbody><tr><td>Message</td><td>在執行 Camel Route 期間建立的出入站訊息</td></tr><tr><td>Headers</td><td>鍵值對，可定義訊息(Message)的屬性或是要儲存的自定義值</td></tr><tr><td>Body</td><td>放置訊息內容的位置</td></tr><tr><td>Exchange</td><td>Message 的容器，保存當前出入的訊息，和有關當前請求的其它元數據</td></tr></tbody></table><h2 id=components-and-endpoints>Components and endpoints</h2><p><code>Camel</code> 中的 <code>endpoint</code> 是 <code>Route</code> 的基石。它們是接收、發送訊息的一部分，由 <code>component</code> 實現，它們可以與外部系統進行整合，像是</p><ul><li>file</li><li>messaging</li><li>web service</li><li>cloud app</li></ul><h2 id=example-1>Example</h2><p>以下是複雜一點的範例。</p><h3 id=example-1-1>Example 1</h3><p>以下是一個透過 <code>timer.period</code> 傳入秒數，並定期運行該 Route。<code>greeting.word</code> 和 <code>timer.period</code> 都是環境變數</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Component</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DemoRouteBuilder</span> <span style=color:#66d9ef>extends</span> RouteBuilder <span style=color:#f92672>{</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>configure</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
        <span style=color:#75715e>// TODO Auto-generated method stub
</span><span style=color:#75715e></span>        from<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;timer:hello?period={{timer.period}}&#34;</span><span style=color:#f92672>)</span>
                <span style=color:#f92672>.</span><span style=color:#a6e22e>setBody</span><span style=color:#f92672>(</span>simple<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;{{greeting.word}}, Hello from timer!&#34;</span><span style=color:#f92672>))</span>
                <span style=color:#f92672>.</span><span style=color:#a6e22e>to</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;log:out&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

<span style=color:#f92672>}</span>
</code></pre></div><p>結果的 log</p><pre><code>2022-05-02 12:14:44.945  INFO 13332 --- [- timer://hello] out                                      : Exchange[ExchangePattern: InOnly, BodyType: String, Body: Itachi, Hello from timer!]
2022-05-02 12:14:45.934  INFO 13332 --- [- timer://hello] out                                      : Exchange[ExchangePattern: InOnly, BodyType: String, Body: Itachi, Hello from timer!]
2022-05-02 12:14:46.951  INFO 13332 --- [- timer://hello] out                                      : Exchange[ExchangePattern: InOnly, BodyType: String, Body: Itachi, Hello from timer!]
</code></pre><h3 id=example-2>Example 2</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Component</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MethodRouteBuilder</span> <span style=color:#66d9ef>extends</span> RouteBuilder <span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>configure</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
        <span style=color:#75715e>// TODO Auto-generated method stub
</span><span style=color:#75715e></span>        from<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;timer:hello?period={{timer.period}}&amp;delay=2000&#34;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>routeId</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;hello&#34;</span><span style=color:#f92672>)</span>
                <span style=color:#f92672>.</span><span style=color:#a6e22e>transform</span><span style=color:#f92672>().</span><span style=color:#a6e22e>method</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;myBeanServiceImpl&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;saySomething&#34;</span><span style=color:#f92672>)</span>
                <span style=color:#f92672>.</span><span style=color:#a6e22e>log</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;&gt;&gt;&gt; ${body}&#34;</span><span style=color:#f92672>)</span>
                <span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>(</span>simple<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;${body} contains &#39;foo&#39;&#34;</span><span style=color:#f92672>))</span>
                <span style=color:#f92672>.</span><span style=color:#a6e22e>to</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;log:foo&#34;</span><span style=color:#f92672>)</span>
                <span style=color:#f92672>.</span><span style=color:#a6e22e>end</span><span style=color:#f92672>()</span>
                <span style=color:#f92672>.</span><span style=color:#a6e22e>to</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;stream:out&#34;</span><span style=color:#f92672>);</span> <span style=color:#75715e>// System.in、System.out、System.err
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>

<span style=color:#f92672>}</span>

</code></pre></div><h3 id=summary>Summary</h3><ol><li><code>Camel</code> 的 <code>Timer</code> 組件(component) 可用於定期觸發路由(Route)</li><li><code>transform</code> 我們想要更改訊息的內容，透過 <code>method</code> 呼叫 <code>bean()</code> 方法。Camel 會在 Spring boot 註冊表中找到名為 <code>myBeanServiceImpl</code> 的 <code>Bean</code>，而 <code>method</code> 第二個參數則是呼叫的方法</li><li><code>filter</code> 告訴 <code>Camel</code> 根據表達式過濾訊息</li><li>最後 <code>to</code> 則是以表準輸出進行訊息打印</li></ol><p>範例<a href=https://github.com/CCH0124/camel-example>鏈結</a></p><h2 id=ref>Ref</h2><ul><li><a href=https://reflectoring.io/spring-camel/>reflectoring</a></li><li><a href=https://tomd.xyz/camelstepbystep/>Apache Camel</a></li></ul></div><div class="d-flex flex-row justify-content-around"><h3 class="mb-1 mt-1 text-left mr-4"><a href=/blog/2020-12-08-jpa-note/ title="Spring Boot JPA Note"><i class="nav-menu fas fa-chevron-circle-left"></i></a></h3><h3 class="mb-1 mt-1 text-left ml-4"><i class="nav-menu-disabled fas fa-chevron-circle-right"></i></h3></div></main><footer class="mt-2 mb-4 text-center"><span class=markdownify>short copyright message</span>
<span>&#183;
<i><a href=https://github.com/darshanbaral/aafu>aafu</a></i>
by
<a href=https://www.darshanbaral.com/>darshan</a></span></footer></body></html>