<!doctype html><html lang=en-us style=max-width:1000px;margin:auto><head><title>Kevin Blog</title><meta name=theme-color content><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta name=description content="Kevin learning"><meta name=author content="Kevin Chen"><meta name=generator content="aafu theme by Darshan in Hugo 0.83.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.15.2/css/all.css integrity=sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu crossorigin=anonymous><link rel=stylesheet href=https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css><link rel=stylesheet href="//fonts.googleapis.com/css?family=Didact+Gothic%7CRoboto:400%7CRoboto+Mono"><link rel=stylesheet href=/css/aafu_pinkish.css><link rel=stylesheet href=/css/aafu.css><script>var themeColor=document.querySelector("meta[name=theme-color]");window.onload=()=>{themeColor.content=getComputedStyle(document.body)["background-color"];let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")},window.onresize=()=>{let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")}</script></head><body class=container><main style="min-height:calc(100vh - 60px)"><div class="d-flex flex-row row p-2"><h3 class="main-menu mr-3"><a href=https://cch0124.github.io/>Home</a></h3><h3 class="main-menu mr-3"><a href=/blog>Blog</a></h3><h3 class="main-menu mr-3"><a href=/project>Project</a></h3><h3 class="main-menu mr-3"><a href=/life>Life</a></h3><h3 class="main-menu mr-3"><a href=/kubernetes>Kubernetes</a></h3><h3 class="main-menu mr-3"><a href=/code>Coding</a></h3></div><div class=mb-3><h1 class=top-h1 style=font-size:2.75em>交換器基本介紹</h1><p class=mb-1>March 28, 2016</p><p>&mdash;</p></div><div class=content><p>Switch 在網路設備中負責<strong>轉發網路封包</strong>。但，轉發這動作之前，Switch 也必須知道封包轉發的目的地以及要從哪一個埠轉發出去。</p><h2 id=switch-主要功能>Switch 主要功能</h2><ul><li>能夠增加網路的可用<code>頻寬</code></li><li>製作出 MAC table<ul><li>分析其中的來源端與目的端的 <code>MAC</code> 位址</li><li>藉由 MAC table 正確的轉發網路封包</li></ul></li><li>擁有較高速的內部結構</li><li>擁有比較多的埠介面</li><li>跟傳統的閘道器（Bridge）比較起來，交換器能夠提供更多的網路流量</li></ul><h3 id=mac-位址學習>MAC 位址學習</h3><p>Switch 會從它們的埠上監聽所傳進來的 <code>Frame</code>（經過交換器的網路封包稱之為 Frame），檢測這些資料的來源端 MAC 位址，並且把 MAC 位址與埠號的對應關係記錄下來，儲存在本地端的 <code>MAC Address Table</code> 或是 <code>Content-addressable Memory (CAM) Table</code>。
當 Switch 再次收到 Frame，會先至 <code>MAC Address Table</code> 中察看哪個埠可以轉發至目的地 MAC 位址，如果有在 <code>MAC Address Table</code>，則這 Frame 會從學習到的埠轉發出去，否則這 Frame 會從除了來源埠之外的埠轉發出去。</p><blockquote><p>當 Switch 收到 Frame 之後，一定會從所有其他的埠轉發出去，除了來源埠之外。這種轉發到除來源埠以外的其他埠的動作，稱為「Flooding」。用這種 Flooding 的動作來轉送Frame 很沒有效率，因為會浪費很多網路頻寬。</p></blockquote><h3 id=switch-傳送-frame-的模式>Switch 傳送 Frame 的模式</h3><h4 id=store-and-forward>Store and Forward</h4><ul><li>交換器會先把 Frame 完整地接收下來，然後才進行轉發的動作<ul><li>來源端及目的端的 MAC 位址都能夠被讀取</li></ul></li><li>CRC（Cyclic Redundancy Check）錯誤檢查動作會被執行<ul><li>檢查失敗，Frame 會被遺棄</li></ul></li><li>確保 Frame 中資料的正確性</li><li>較費時<ul><li>延遲時間與 Frame 的資料長度有關</li></ul></li></ul><h4 id=cut-though>Cut-Though</h4><p>雖然有些交換器在這種模式下只想讀取 MAC 位址，但還是有某些交換器會讀取 CRC 值並記錄下錯誤數目。</p><ul><li>一旦接收到 Header 之後，看到目的端的 MAC 位址，馬上執行 Frame 的轉發動作</li><li>比 <code>Store and Forward</code> 快上許多</li><li>所需要的時間，不會因為 Frame 的長度變長就跟著變多<ul><li>閘道器及 Switch 只想取得目的端的 MAC 位址，而目的端的 MAC 位址都一定會存放在 Frame 資料內最前面的 Header 之內</li></ul></li><li>CRC 值錯誤，不會將這個 Frame 遺棄，而是針對設定值自動或手動切換成 <code>Store and Forward</code><ul><li>允許切換的 Cut-Though 又稱為 <code>Adaptive Cut-Though</code> 模式</li></ul></li></ul><h4 id=fragment-free>Fragment-Free</h4><ul><li>Switch 只讀取 Frame 的前 64 個 bytes（乙太網路中 Frame 最小的資料單位）</li><li>速度比 <code>Cut-Though</code> 更快</li><li>錯誤的 Frame，會把 Frame 丟棄<ul><li>與 <code>Cut-Though</code> 不同的地方</li></ul></li><li>也稱為 <code>Modified Cut-Though</code> 模式</li></ul><blockquote><p>乙太網路中碰撞幾乎發生在前 64 個 bytes 中，一旦發生碰撞，就會產生小於 64 個 bytes 的 Frame 資料。Switch 經由讀取前 64 個 bytes 資料，可初步篩選經由碰撞所產生的 Frame 資料</p></blockquote><h2 id=switch-學習來源端-mac-位址過程>Switch 學習來源端 MAC 位址過程</h2><h6 id=範例拓譜>範例拓譜</h6><p><img src=https://i.imgur.com/eEpGXFZ.png alt></p><p>假設 FTP 發送一個 Frame 要給 WWW，這 Frame 會經由 E0 介面傳送 Switch 並使用 <code>Store and Forward</code> 模式，則此 Frame 會先暫存在緩衝區。
因為這台 Switch 還沒學到這個 MAC 位址應要轉發至哪個埠，會以 <code>Flooding</code>，經由其它的埠把這 Frame 轉發出去，然而接收到此 Frame 同時，Switch 也學到從 E0 這個埠出去可以到達 FTP 這 Server（因 Switch 能經由 E0 介面收到由 FTP Server 的 MAC 位址發送的 Frame）。</p><p>這學習到的資訊成為 <code>MAC Address Table</code> 一筆資料</p><table><thead><tr><th>Port</th><th>MAC address</th></tr></thead><tbody><tr><td>E0</td><td>57:A4:67:37:22:90</td></tr></tbody></table><p><code>MAC Address Table</code> 中的資訊並非永遠存在，會依據 Switch 的設定而影響。</p><blockquote><p>此學習有助於 Frame 的篩選動作，因為 Frame 只會發送到真正需要送往的埠而已，這樣就可以節省整體的網路頻寬，這種篩選動作稱為「Frame Filtering」</p></blockquote><h3 id=broadcast-與-multicast-的轉發過程>Broadcast 與 Multicast 的轉發過程</h3><p><code>Broadcast</code> 與 <code>Multicast</code> 所代表的 MAC 位址，根本不可能存在於真正的網路中。</p><h2 id=switch-在-vlan-中的傳輸封包方式>Switch 在 VLAN 中的傳輸封包方式</h2><ul><li>在同一個 <code>VLAN</code> 中的電腦才可以互相傳遞資料<ul><li>事實上是透過限制資料的轉送來達到這種 <code>VLAN</code> 的資料傳遞過程</li><li>Switch 會了解哪些埠是屬於哪個 <code>VLAN</code>，會限制 <code>Flooding</code> 只能送往同一個 VLAN 之中</li></ul></li></ul><blockquote><p>前面所提到的範例是因為預設上所有的埠都是屬於預設的 <code>VLAN</code> 中，因此 <code>Flooding</code> 動作不會有什麼問題</p></blockquote><h3 id=trunk>Trunk</h3><p>當 <code>VLAN</code> 資料要跨越多個 Switch 轉發至其它 Switch 所連接的同一 <code>VLAN</code>，須使用<code>Trunk</code> 技術在資料中增加一個 Tag，來表示目前這份資料是屬於哪一個 <code>VLAN</code>。傳遞資料都透過一條網路線連接起來，這條網路線必須要能傳遞承載所有 <code>VLAN</code> 的資料。</p><p>貼上 tag 後，封包會變成：</p><ol><li>目的端位址資訊，占封包的 6 個位元組。</li><li>來源端位址資訊，占封包的 6 個位元組。</li><li>802.1Q 協定專用 tag，占封包的 4 個位元組。</li><li>用來指明資料長度或是乙太網路種類的資訊，占封包的 2 個位元組。</li><li>資料本身，占封包的 46∼1,500 個位元組。</li><li>FCS，占封包的 4 個位元組。</li></ol><h4 id=8021q>802.1Q</h4><ul><li>在 <code>VLAN</code> 中用來連接多個 Switch 與 Router</li><li>Cisco的 設備在 Fast Ethernet 和 Gigabit Ethernet 的介面上都支援此協定</li></ul><h5 id=native-vlan>native VLAN</h5><ul><li><code>native VLAN</code> 有一個作用，就是所有沒有被貼上標籤的資料都會被送往這個 <code>native VLAN</code>。</li><li>每個 <code>VLAN</code> 都會有一個 ID，用來區分各個 <code>VLAN</code>，而 <code>native VLAN</code> 的預設ID 是 <code>VLAN 1</code>。</li></ul><blockquote><p>只有 <code>802.1Q</code> 才有 <code>native VLAN</code>，<code>ISL</code> 並沒有 <code>native VLAN</code></p></blockquote><h4 id=isl>ISL</h4><ul><li>是 Cisco 設備專用<ul><li>並非每款都支援</li></ul></li><li>與任何協定無關，因此 ISL 能夠封裝任何種類的上層協定資料（屬於 OSI Mpdel 第二層）</li><li>新增的表頭大小為 26 個位元組<ul><li>包含VLAN ID 和 BPDU 資訊等</li></ul></li><li>新增的 CRC 大小為 4 個位元組</li></ul><blockquote><p>ISL 協定所使用的資料封包長度超過乙太網路所能接受的長度，一旦不支援 ISL 協定的設備收到這樣的封包，會認為是錯誤的封包而直接遺棄。乙太網路的正確封包大小是 64 到 1,518 個位元組。</p></blockquote><h2 id=switch-可能造成的問題>Switch 可能造成的問題</h2><p>範例拓譜</p><p><img src=https://i.imgur.com/VBqbY7d.png alt></p><h5 id=同一個網路中使用多個交換器>同一個網路中使用多個交換器</h5><ol><li>廣播風暴（Broadcast Storm）</li><li>發送多個重複資料（Multiple Frame Copies）</li><li>MAC 位址資料庫不一致（MAC Address Table Instability）</li></ol><ul><li>Broadcast Storm
假設 Server 發送 ARP（Address Resolution Protocol） Request 來根據 IP 查找 MAC 位址時，S1 收到 ARP 廣播之後，把廣播封包 Flooding 出去，S1 會把這個封包從兩個方向再送給 S2，而 S2 接收廣播後，把廣播封包再送給 S1。
使目的地接收廣播封包，但是這樣的無窮迴圈所造成的廣播風暴會繼續，並占據著網路頻寬，而且網路上的廣播封包會越來越多，直到整個網路被這樣的廣播封包占滿為止。</li></ul><blockquote><p>廣播風暴不只會造成網路癱瘓，也會耗盡網路上各個設備的資源，因為這種廣播封包的處理過程需要CPU來處理。解決這個問題的方法就是避免迴圈的產生（Loop Avoidance）</p></blockquote><ul><li>Multiple Frame Copies<ul><li>只要避免迴圈產生即可</li></ul></li><li>MAC Address Table Instability<ul><li>迴圈的避免</li></ul></li></ul><p>而 STP（Spanning Tree Protocol）就是用來避免網路迴圈的問題發生。</p></div><div class="d-flex flex-row justify-content-around"><h3 class="mb-1 mt-1 text-left mr-4"><a href=/blog/2016-03-22-router/ title=路由器基本介紹><i class="nav-menu fas fa-chevron-circle-left"></i></a></h3><h3 class="mb-1 mt-1 text-left ml-4"><a href=/blog/2016-03-30-subnetting/ title=子網路切割><i class="nav-menu fas fa-chevron-circle-right"></i></a></h3></div></main><footer class="mt-2 mb-4 text-center"><span class=markdownify>short copyright message</span>
<span>&#183;
<i><a href=https://github.com/darshanbaral/aafu>aafu</a></i>
by
<a href=https://www.darshanbaral.com/>darshan</a></span></footer></body></html>