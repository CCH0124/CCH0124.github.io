<!doctype html><html lang=en-us style=max-width:1000px;margin:auto><head><title>Kevin Blog</title><meta name=theme-color content><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta name=description content="Kevin learning"><meta name=author content="Kevin Chen"><meta name=generator content="aafu theme by Darshan in Hugo 0.83.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.15.2/css/all.css integrity=sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu crossorigin=anonymous><link rel=stylesheet href=https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css><link rel=stylesheet href="//fonts.googleapis.com/css?family=Didact+Gothic%7CRoboto:400%7CRoboto+Mono"><link rel=stylesheet href=/css/aafu_pinkish.css><link rel=stylesheet href=/css/aafu.css><script>var themeColor=document.querySelector("meta[name=theme-color]");window.onload=()=>{themeColor.content=getComputedStyle(document.body)["background-color"];let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")},window.onresize=()=>{let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")}</script></head><body class=container><main style="min-height:calc(100vh - 60px)"><div class="d-flex flex-row row p-2"><h3 class="main-menu mr-3"><a href=https://cch0124.github.io/>Home</a></h3><h3 class="main-menu mr-3"><a href=/blog>Blog</a></h3><h3 class="main-menu mr-3"><a href=/project>Project</a></h3><h3 class="main-menu mr-3"><a href=/life>Life</a></h3><h3 class="main-menu mr-3"><a href=/kubernetes>Kubernetes</a></h3><h3 class="main-menu mr-3"><a href=/code>Coding</a></h3></div><div class=mb-3><h1 class=top-h1 style=font-size:2.75em>Docker 資源詳解</h1><p class=mb-1>March 30, 2018</p><p>&mdash;</p></div><div class=content><h1 id=table-of-content>Table of content</h1><ul><li><a href=#Docker-image>Docker image</a></li><li><a href=#Docker-Port-mapping>Docker Port mapping</a></li><li><a href=#Docker-Volume-mapping>Docker Volume mapping</a></li><li><a href=#Docker-Networking>Docker Networking</a></li></ul><h2 id=docker-image>Docker image</h2><p><code>Dockerfile</code> 是建構 <code>image</code> 的檔案，建構 <code>image</code> 時會讀取 <code>Dockerfile</code> 的指令一層一層的建構。而 <code>container</code> 是由 image 建構出來的實例。</p><p><img src=https://i.imgur.com/RsXurEd.png alt></p><h3 id=image-特點>image 特點</h3><h5 id=分層儲存>分層儲存</h5><p>當需要修改 image 內的某個檔案時，只會對上方的讀寫層進行改動，不會覆蓋下層既有檔案系統內容。</p><p><img src=https://i.imgur.com/ix2XQlW.png alt></p><h5 id=copy-on-write>Copy-on-Write</h5><p>從分層儲存可以知道，在建立 <code>container</code> 之後我們會在一個可寫層上並進行操作，但是在 <code>image layers</code> 的檔案能否修改 ? 是可以的，會複製該檔案至可寫層。</p><p><img src=https://i.imgur.com/QBHKTL0.png alt></p><h3 id=dockerfil-arg>Dockerfil Arg</h3><p><img src=https://i.imgur.com/7WsR2E0.png alt title=網管人></p><p>by <a href=https://www.netadmin.com.tw/netadmin/zh-tw/technology/7BD73E2A172C4847A3F72D238ACA5148>網管人</a></p><h5 id=cmd-vs-entrypoint>CMD vs ENTRYPOINT</h5><p>在 <code>Dockerfile</code> 中，只能有一個 <code>ENTRYPOINT</code> 或 <code>CMD</code> 指令，如果有多個 <code>ENTRYPOINT</code> 或 <code>CMD</code> 指令則以最後一個為準。</p><ul><li>ENTRYPOINT<ul><li>往往用於設置容器啟動後的第一個命令，這對一個容器來說往往是固定的。</li><li>執行 <code>docker run</code> 如果帶有其他命令參數，不會覆蓋 <code>ENTRYPOINT</code> 指令</li><li><code>docker run</code> 的 <strong>&ndash;entrypoint</strong> 可以覆蓋 <code>Dockerfile</code> 中 <code>ENTRYPOINT</code> 設置的命令。</li></ul></li><li>CMD<ul><li>往往用於設置容器啟動的第一個命令的默認參數，這對一個容器來說可以是變化的。<code>docker run &lt;command></code> 往往用於給出替換 <code>CMD</code> 的臨時參數。</li><li><code>docker run</code> 如果帶有其他命令參數，將會覆蓋 <code>CMD</code> 指令。</li><li>如果在 <code>Dockerfile</code> 中，還有 <code>ENTRYPOINT</code> 指令，則 <code>CMD</code> 指令中的命令將作為 <code>ENTRYPOINT</code> 指令中的命令的參數。</li></ul></li></ul><h3 id=example>Example</h3><h5 id=nginx-dockerfile>Nginx Dockerfile</h5><pre><code class="language-shell=" data-lang="shell=">FROM ubuntu:14.04

RUN apt-get update &amp;&amp; apt-get install -y nginx
COPY . /var/www/html/
EXPOSE 80
#ENTRYPOINT [&quot;nginx&quot;]
CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]

</code></pre><h5 id=build-dockerfile>Build Dockerfile</h5><p>使用 <code>docker build -t {ImageName}:{tag} .</code> 建構</p><p>使用 <code>docker images</code> 查看建構的 image</p><pre><code class="language-shell=" data-lang="shell=">REPOSITORY                                          TAG                 IMAGE ID            CREATED             SIZE
nginx                                               v0                  55077273116a        20 minutes ago      222MB

</code></pre><h2 id=docker-port-mapping>Docker Port mapping</h2><p>當運行一個 Docker 實例時</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker run
</code></pre></div><p>，此 <code>container(實例)</code> 會在 <code>Docker host</code> 上。假設該 <code>container</code> 為一個 web 應用程式，在 <code>container</code> 中 port 號為 5000，那用戶該如何訪問存取該 web 應用程式，以客戶端來說會輸入 IP 或 Domain，但 <code>container</code> 預設給予的 IP 為私有 IP，因此客戶端無法與私有 IP 連接，可以透過 port 映射方式，將 <code>container</code> 中 web 應用程式的 5000 port 號，映射到外部主機 80 port，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker run -p 80:5000 
</code></pre></div><p>所以客戶端瀏覽時透過外部主機連線，外部主機在路由至 port 5000 的 <code>container</code>。</p><p><img src=https://i.imgur.com/6e9bP4z.png alt title=示意圖></p><h2 id=docker-volume-mapping>Docker Volume mapping</h2><p>依照上面的描述，當用 <code>container</code> 建立 mysql 時並在 <code>container</code> 生命週期內，其資料儲存都是存在的。不過，只要做了<strong>刪除</strong>該 mysql 的 <code>container</code> 動作，則該儲存在 mysql 上的資料全都一併消失。因此可藉由 <code>volume</code> 或 <code>bind Mounts</code> 等進行持續的儲存。</p><p>以 <code>volumn</code> 來說會有這些優勢</p><ul><li>遷移與備份較容易</li><li>可多個 <code>container</code> 共享</li><li>允許應用程式在遠端主機或雲端儲存 <code>volume</code></li><li>不會增加 <code>container</code> 的大小</li><li>不依賴 <code>Docker</code> 的生命週期</li></ul><p><img src=https://i.imgur.com/nqDLfnx.png alt title=volumn></p><p><img src=https://i.imgur.com/lnjEz4a.png alt></p><blockquote><p>Linux 系統中 Docker 的數據預設在 <code>/var/lib/docker</code> 中</p></blockquote><h5 id=command>Command</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker volume create
docker volume inspect
docker volume ls
docker volume prune
docker volume rm
</code></pre></div><h2 id=docker-networking>Docker Networking</h2><p>在 <code>Docker</code> 的網路隔離技術，用到了</p><ul><li>namespace<ul><li>會建立一個擁有網路介面、路由、防火牆等網路資源的環境</li></ul></li><li>Linux Bridge<ul><li>將不同主機的網路介面連接</li><li><code>Docker</code> 安裝完後會有一個預設 <code>docker0</code> 的 <code>Linux Bridge</code></li></ul></li><li>Veth Pair<ul><li>將 <code>container</code> 與本機網路、外部網路達到通訊</li></ul></li></ul><p>在 <code>Docker</code> 會有四種模式</p><h5 id=none>None</h5><ul><li><code>container</code> 擁有自己的 <code>namespace</code>，但不幫 <code>container</code> 進行任何的網路配置</li><li><code>container</code> 只包含 <code>loopback</code> 介面卡，需要使用者自行配置</li></ul><p><img src=https://i.imgur.com/7Hi5LR4.png alt></p><h5 id=bridge>Bridge</h5><ul><li>是利用 <code>Iptables</code> 進行 <code>NAT</code> 和 <code>port</code> 映射</li><li>此模式下同一主機上的 <code>container</code> 可以互相通訊</li><li><code>container</code> 的 <code>IP</code> 地址從主機外部不能訪問</li></ul><p><img src=https://i.imgur.com/3RK6Zgc.png alt></p><h5 id=host>Host</h5><ul><li>不會為 <code>container</code> 建立隔離的網路環境，</li><li><code>container</code> 共享本機的網路命名空間（<code>/var/run/docker/netns/default</code>），網路配置與本機一致</li><li><code>container</code> 透過本機的網路介面卡，實現與外部的通訊</li></ul><p><img src=https://i.imgur.com/NsKKUnP.png alt></p><h5 id=container>Container</h5><ul><li>新創建的容器和已經存在的某個容器共享同一個 <code>namespace</code>，該容器不會擁有自己的網卡</li><li>此模式下的 <code>container</code> 只有網路方面共享數據，文件系統、行程列表等其它方面還是隔離的</li></ul><p><img src=%22https://i.imgur.com/MDefWlA.png%22 alt></p><h5 id=command-1>Command</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker network connect
docker network create
docker network diconnect
docker network inspect
docker network ls
docker network prune
docker network rm
</code></pre></div><h2 id=ref>Ref</h2><ul><li><a href=https://k2r2bai.com/2016/01/05/container/docker-network/>networking 圖來源</a></li><li><a href="https://www.youtube.com/watch?v=fqMOX6JJhGo">Docker Tutorial for Beginners - A Full DevOps Course on How to Run Applications in Containers - freeCodeCamp</a></li></ul></div><div class="d-flex flex-row justify-content-around"><h3 class="mb-1 mt-1 text-left mr-4"><a href=/blog/2018-03-29-docker-command/ title="basic command of docker"><i class="nav-menu fas fa-chevron-circle-left"></i></a></h3><h3 class="mb-1 mt-1 text-left ml-4"><a href=/blog/2018-05-26-mariadb/ title="mariadb 安裝使用"><i class="nav-menu fas fa-chevron-circle-right"></i></a></h3></div></main><footer class="mt-2 mb-4 text-center"><span class=markdownify>short copyright message</span>
<span>&#183;
<i><a href=https://github.com/darshanbaral/aafu>aafu</a></i>
by
<a href=https://www.darshanbaral.com/>darshan</a></span></footer></body></html>