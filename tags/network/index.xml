<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Network on</title><link>https://cch0124.github.io/tags/network/</link><description>Recent content in Network on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 05 Jan 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://cch0124.github.io/tags/network/index.xml" rel="self" type="application/rss+xml"/><item><title>router-on-a-stick</title><link>https://cch0124.github.io/blog/2020-01-05-router-on-a-stick/</link><pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2020-01-05-router-on-a-stick/</guid><description>環境 這邊配置一台 L3 交換器、路由器、VM 和 PC。這一次實驗主要是實現單臂路由(router-on-a-stick)，單臂路由簡單來說是用來實現不同 VLAN 間的通訊，其接口需配置 trunk 協定，在藉由一個接口建立每個 VLAN 的網路 gateway。當 VLAN 有設置後，其每個封包都會帶著 VLAN 標籤，而這個標籤會在設定單臂路由的路由器進行解析，這樣就能讓不同 VLAN 可以相互通訊。至於 VLAN 相關操作和原理可查看之前寫的內容。
配置 ESW1 交換器與 R1 路由器 將接口啟動，並使用 hostname 配置 ESW1 的主機名稱。
ESW1#conf t ESW1(config)#hostname IT@L3 % Hostname contains one or more illegal characters. % Hostname &amp;#34;IT@L3&amp;#34; is not a legal LAT node name, Using &amp;#34;CISCO_18F100&amp;#34; IT@L3(config)#interface fastEthernet 1/0 IT@L3(config-if)#no shutdown IT@L3(config-if)#interface fastEthernet 1/15 IT@L3(config-if)#no shutdown IT@L3(config-if)#exit 配置 telnet 相關配置以及交換機上安全設定，有關 telnet 配置可參考之前文章所做的實驗。</description></item><item><title>VLAN 介紹</title><link>https://cch0124.github.io/blog/2019-11-10-vlan/</link><pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2019-11-10-vlan/</guid><description>VLAN(Virtual LAN) 是交換器上一個很重要的技術，它可以去規劃一個區域網路內的組織，也就是可將不同類型的部門網路進行邏輯上的網路切分。VLAN 的技術可將一台交換器上的埠分成幾個群，而每個群又可透過 VLAN 特性再做一些詳細設定，VLAN 邏輯上根據切分的群就有幾個廣播網域(Broadcast Domain)，所以這也讓不同的 VLAN 再域設下不能直接相互通訊。透過 VLAN 技術切分的廣播網域相比原本同一 LAN 下的廣播域對網路負擔要來的小。
VLAN 資料轉發 在多個交換器之間設定的 VLAN，則域設下只有同一 VLAN 才能通訊。在預設下交換器都屬於同一 VLAN 中，因此針對於接收到的封包對所有埠做 flooding 動作是對的，因此做了 VLAN 後，VLAN 間傳遞封包只會在該 VLAN 中進行 flooding。另外一個重點是 trunk，它用來對跨越多個交換器的 VLAN 進行轉發，要設置 trunk 則接口需要是 FastEthernet 以上才可設定。
trunk 資料轉發 trunk 會在封包內增加一個標籤，用來指名這封包是屬於哪個 VLAN，而這標邊被新增後將傳往下個設備。下個設備收到之後，再根據標籤來得知此封包是屬於哪個 VLAN，然後再轉發至所屬的 VLAN。
這邊將透過下面架構進行 VLAN 操作，這邊大致上會以 ESW1 做設定，ESW2 則是對應這邊不再多做說明與設置。
查看 ESW1 交換器 VLAN 訊息，發現所有接口預設都是 VLAN 1，在這種情況下我們的路由器 R1 至 R6 都能相互通訊。
ESW1#show vlan-switch VLAN Name Status Ports ---- -------------------------------- --------- ------------------------------- 1 default active Fa1/0, Fa1/1, Fa1/2, Fa1/3 Fa1/4, Fa1/5, Fa1/6, Fa1/7 Fa1/8, Fa1/9, Fa1/10, Fa1/11 Fa1/12, Fa1/13, Fa1/14, Fa1/15 1002 fddi-default active 1003 token-ring-default active 1004 fddinet-default active 1005 trnet-default active VLAN Type SAID MTU Parent RingNo BridgeNo Stp BrdgMode Trans1 Trans2 ---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ------ 1 enet 100001 1500 - - - - - 1002 1003 1002 fddi 101002 1500 - - - - - 1 1003 1003 tr 101003 1500 1005 0 - - srb 1 1002 1004 fdnet 101004 1500 - - 1 ibm - 0 0 1005 trnet 101005 1500 - - 1 ibm - 0 0 接著我們配置 VLAN 觀察，R1 和 R4 我們讓它預設；R2 和 R5 設至為 VLAN 20；R3 和 R6 為 VLAN 30。</description></item><item><title>SSH</title><link>https://cch0124.github.io/blog/2019-11-15-cisco-ssh/</link><pubDate>Fri, 08 Nov 2019 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2019-11-15-cisco-ssh/</guid><description>拓樸 官網說明，啟用 SSH 需要四個步驟：
配置 hostname 配置 DNS domain 產生要使用的 SSH key vty 啟用 SSH transport 表明支援 SSH 與 telnet 比較之下，重點在於 SSH 有加密的機制，因此在傳遞資訊方面較為安全。
R1 設定 介面卡設定 R1#configure terminal Enter configuration commands, one per line. End with CNTL/Z. R1(config)#interface fastEthernet 0/0 R1(config-if)#ip address 192.168.6.200 255.255.255.0 R1(config-if)#no shutdown *Mar 1 00:03:03.563: %LINK-3-UPDOWN: Interface FastEthernet0/0, changed state to up *Mar 1 00:03:04.563: %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/0, changed state to up SSH 設定 R1(config)#ip domain-name itachi.</description></item><item><title>cisco telnet</title><link>https://cch0124.github.io/blog/2019-11-06-cisco-telnet/</link><pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2019-11-06-cisco-telnet/</guid><description>拓樸 本實驗將 ubuntu16 與 VMware 的虛擬機做鏈接，因此 R1 和 ubuntu16 為同一個網段。本實驗練習設定以及用 wireshark 觀察 telnet。
遠端設備 原則上有以下方式可以連接設備
Console Terminal Remote Terminal Telnet SSH R1 設定 IP 配置 R1(config)#interface fastEthernet 0/0 R1(config-if)#ip address 192.168.6.200 255.255.255.0 R1(config-if)#no shutdown 啟用遠端 line vty 用來設定 0 到 4 的介面，藉由 login 設定登入時輸入帳號與密碼。要取消 telnet 使用 no login local 指令。
R1(config)#line vty 0 4 R1(config-line)#login R1(config-line)#exit R1(config)#username cisco7200 privilege 15 password cisco7200 R1(config)#exit R1#wr Building configuration... [OK] login 和 login local 在認證方面有些許差異。</description></item><item><title>throughout</title><link>https://cch0124.github.io/blog/2019-05-21-throughput/</link><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2019-05-21-throughput/</guid><description>Throughput（吞吐量）是指系統可以在指定的時間內處理的單元的數量。像是 internet 之類的通訊網路的環境中，吞吐量是訊息成功傳遞的速率。
什麼是 Throughput 網路吞吐量通常表示為平均值，以每秒位數（bps）為單位，或者在某些情況下以每秒 data packets 為單位。吞吐量是網路連接性能和質量的重要指標。不成功的訊息傳遞的高比率，會導致較低的吞吐量和降低性能的問題。
網路設備通過交換 data packets 進行通訊。吞吐量表示從網路上的一個點到另一個點的成功數據包傳送的級別。沿途丟棄 data packets 會降低吞吐量和網路連接質量。對於某些即時服務要求的吞吐量就會較高。
網路吞吐量受許多因素的影響，這些屬性包括
物理硬體的處理能力 電纜和路由器 網路擁塞和 data packets 丟失也會對吞吐量產生影響 Bandwidth 與 Throughput 差異 Bandwidth（頻寬）是指 internet 通道的大小。internet 通訊通常用稱為 data packets 的數據形式產生。頻寬是指這些 data packets 的大小以及可以同時通過 internet 通道傳輸的數量。與吞吐量的一個重要區別是頻寬是指 internet 通道的實際大小或容量；吞吐量是指實際傳輸的 data packets 的數量。
使用高速公路的比喻，頻寬將是在一段時間內沿著該高速公路行駛的汽車總數（越多通道所傳送的資料越多）。事故和道路封閉後，吞吐量將是實際通過高速公路長度的汽車數量。
Throughput 和網際網路速度 大多數人認為 internet 速度是下載或上傳檔案所需的時間。速度也可以指硬體設備或 internet 連接的 &amp;ldquo;rated speed&amp;rdquo;。
例如，經常聽到超快 100 Mbps 的 internet 連接。預設情況下，這些速度表示特定 Internet 連接的吞吐量。事實上，這些 internet 連接速度可以更準確的描述為連接的實際帶寬，實際數據傳輸容量或吞吐量可能要低得多。</description></item><item><title>負載均衡</title><link>https://cch0124.github.io/blog/2019-04-06-hsrp/</link><pubDate>Sat, 06 Apr 2019 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2019-04-06-hsrp/</guid><description>HSRP Introduction HSRP 是提供 first-hop 來提供高網路可用性的標準方法。它使一組路由器接口能夠協同工作，向 LAN 上的主機呈現單個虛擬路由或 default gateway 的方法。在網路的多個路由器上配置 HSRP 時，它會提供虛擬媒體訪問控制（MAC,virtual Media Access Control）位址和一組已配置的路由器之間共享的 IP 地址。
當其中一個路由器被選擇為 active 路由器，另一個路由器作為 standby 路由器。在一組設有 HSRP 路由器接口中，active 路由器是路由封包的首選路由器；standby 路由器是在 active 路由器出現故障或滿足預設條件時接管路由任務的路由器。
HSRP 支持的任何路由器接口
Implement HSRP Topology 這邊 Cloud1 是透過虛擬機網路卡取得 IP，這邊不詳述。
目標 配置 EIGRP 設定 HSRP 測試 EIGRP Configuration 我將 R1、R2、R3、R4 配置 EIGRP 協定並將 AS 設定為 100。 這邊用 R1、R2 做範例，其中會在 EIGRP 中加入預設路由。
R1 router eigrp 100 network 172.16.1.0 0.0.0.3 redistribute static metric 100000 1000 255 1 1500 R2 router eigrp 100 network 10.</description></item><item><title>ACL</title><link>https://cch0124.github.io/blog/2019-01-22-acl/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2019-01-22-acl/</guid><description>ACL IP Access Control Lists (ACLs)，根據以下內容過濾 IP 數據包：
Source address Destination address Type of packet Any combination of these items 為了要過濾網路流量，ACL 控制是否在路由器 interface 上 forward 或 drop 路由數據包。
Source address of the traffic Destination address of the traffic Upper-layer protocol Standard ACLs 將 IP 數據包的 source address 與 ACL中配置的 address 進行比較，以控制流量，但不能針對特定的網路協定指定允許或拒絕的動作處理。 Extended ACLs 將 IP 數據包的 source address 和 destination address 與 ACL 中配置的地址進行比較或針對特定的網路協定做處置，以控制流量。可以使 extended ACL 更精細，並配置為按以下標準過濾流量：</description></item><item><title>RIP 與子網路切割</title><link>https://cch0124.github.io/blog/2019-01-05-rip/</link><pubDate>Sat, 05 Jan 2019 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2019-01-05-rip/</guid><description>拓樸 學習目標 切割子網路 設定 RIP 協定 ping 和 traceroute 驗證 封包驗證 拓樸子網路分配取切割 定義了 192.168.1.0/24 是給一間學校的網段。其中 R1、R2、R3 是學校三棟大樓的核心。 R1 假設為一年級電腦教室，在介面 e5/0 下給了 40 個主機給一年級使用；R2 假設為二、三年級電腦教室，在介面 e5/0 給了 80 個主機給二年級電腦教室使用；R3 假設為四年級電腦教室，在介面 e5/0 給了 20 個主機給二年級電腦教室使用。但是要如何有效切割子網路才能達到節省 IP 的目標 ? 「必須利用無類別區隔路由（CIDR）技巧來達到節省 IP」。
IP 為 32 bit 組成，IP 位址以 Classful 分類為 A、B、C、D、E 五類。是以 32 bit 以每 8 bit 一組來區隔做不同的類別，如下表。
網路類別 IP 位置範圍 Class A 0.0.0.0 ~ 127.</description></item><item><title>Network Troubleshotting</title><link>https://cch0124.github.io/blog/2018-01-28-network-troubleshotting/</link><pubDate>Sun, 28 Jan 2018 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2018-01-28-network-troubleshotting/</guid><description>通常如果實體設備能正常工作，接下來會藉由一些網路相關的指令或工具進行網路上的除錯。像是確認 A 能否抵達 B 等。下面描述的是一些除錯的指令與工具。
ping 先前有提到過，這邊就不提了
DSN Troubleshotting dig dig 驗證 DNS 主機地址、MX 記錄和所有其他 DNS 記錄，方便了解 DNS 部署情況。
$ dig www.nkust.edu.tw ; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.10.3-P4-Ubuntu &amp;lt;&amp;lt;&amp;gt;&amp;gt; www.nkust.edu.tw ;; global options: +cmd ;; Got answer: ;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 462 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; MBZ: 0005 , udp: 1280 ;; QUESTION SECTION: ;www.</description></item><item><title>Static routes</title><link>https://cch0124.github.io/blog/2017-11-24-static-route/</link><pubDate>Fri, 24 Nov 2017 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2017-11-24-static-route/</guid><description>Routing table 路由器是一個負責將封包送往目的地的設備，而路由器跟路由器之間必須要分享所學習到的資訊，並且把交換的資訊以到鄰居的成本以和使用什麼路由協定等給記錄至一張表格，而這張表格就是 Routing table。
此篇文章範圍是 Static Route 的概念。
The router decides how to send the packet Static Route 手動輸入 網路有變化，需要人員的管理 無須學習 因此速度快 Dynamic Route 做 Routing Protocol 的設定 耗資源 由 router 之間去做協調 網路有變化，會透過 Routing Protocol 學習 Default route （預設路由）所謂的預設路由就是當不知道要將這個封包送往哪裡的時候，就會採用這個預設路由所指定的路徑。
Example 這邊不描述 IP address 的設定。
目標：
設置 R1 Static Route。 R2 和 R3 都各有一條 Default route。 Set R2 &amp;amp; R3 Default route R2 將來自不存在於路由表的目的地給丟置 10.</description></item><item><title>DHCP</title><link>https://cch0124.github.io/blog/2017-11-11-dhcp/</link><pubDate>Sat, 11 Nov 2017 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2017-11-11-dhcp/</guid><description>DHCP DHCP（Dynamic Host Configuration Protocol），屬於第七層的 Application Layer。DHCP 此協定運作於 Server-Client 的架構之中，來讓 Client 端取得網路相關的設定，包含 IP Address、Default Route、DNS。Client 端指的是一般電腦設備，而 Server 端就是DHCP Server。
優點 有效節省 IP 減少維護者負擔 容易維護 DHCP 的 port DHCP Server UDP 67 Client UDP 68 DHCP 分配（Allocate）IP 位址方式 動態分配方式 DHCP Server 上設定好一個 IP Address 範圍以及使用期限，以便回收 IP Address，以便給其它 Client。 靜態分配方式 DHCP Server 根據已定義並手動寫入對應表的 MAC 位址與 IP 位址來分配。 自動分配方式 DHCP Server 可以針對事先已經定義好的 IP Address 範圍來分配 IP Address 給 Client 端，IPAddress 的使用是沒有期限，相對的DHCP Server 會記錄 Client 端使用的 IP Address，以避免 IP Address 衝突。 Client 取得 DHCP 設定過程 Discovery（Client端→DHCP Server） Client 端以 Broadcast 找尋 DHCP Server。設定 DHCP Relay Agent，以達到跨網路尋求的步驟。</description></item><item><title>PPP</title><link>https://cch0124.github.io/blog/2017-11-04-ppp/</link><pubDate>Sat, 04 Nov 2017 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2017-11-04-ppp/</guid><description>PPP 廣域網路協定 廣域網路 廣域網路（Wide Area Network，WAN ）和一般所謂的區域網路不一樣。區域網路通常是指範圍較小的網路區段，可能是同一棟大樓、同一層樓或是一個區域較小的地理位置。 而廣域網路是範圍比較廣的網路區段，一般跨國型的企業都會使用廣域網路來連結位於不同國家的各個分部，好讓資訊能夠相互流通。
PPP 協定 PPP（Point to Point Protocol）協定是普遍被使用的廣域網路協定，如同名稱所示，PPP 協定是指點對點的網路協定，通常用於兩個網路節點的直接連接，例如兩台電腦透過電話線的網路連接，經常使用在寬頻網路連線上。目前許多ADSL 網路服務供應商（ISP ）提供使用者以 PPP 協定的方式撥接到本身的機房，然後再連上網際網路。以往，則大多使用 SLIP（Serial Line Internet Protocol ）協定，該協定採用的是TCP/IP 協定的點對點串列連線的標準。SLIP 協定是很久以前的協定，主要用於串列埠與數據機之間的連線，現在慢慢地已經被 PPP 協定取代。
PPP 協定在廣域網路連線上的定位 PPP 協定算是廣域網路在網路協定第二層封裝協定的種類之一，當網路封包要傳送到廣域網路之前，在網路第二層協定時，就一定會先透過特定的方式進行封裝，而為了保證能使用正確的封裝方式，在設定 Cisco 設備來支援廣域網路時就必須選對正確的封裝協定，而封裝協定的選擇與所使用的廣域網路技術和廣域網路設備有關。 因此，網路管理人員一定要瞭解廣域網路所使用的封裝協定，才能夠正確的選擇並且設定第二層封裝協定。
一般廣域網路的網路協定第二層封裝協定有以下幾個種類：
HDLC PPP SLIP X.25 LAPB 幀中繼（Frame Relay ） ATM 所以 PPP 協定正是其中一種。
PPP RFC 中定義資訊 PPP 協定包含了各種認證方式、加密與解密方式、壓縮資料方式以及 PPP 協定如何與其他網路協定的合作與交互關係。
PPP 協定中的CHAP 協定，也就是握手（Handshake ）協定，用於建立撥號連接。
PPPoE 協定在乙太網路中用於傳輸PPP 協定中的資料，經常使用於ADSL 上。
PPPoA 協定，主要應用在以ATM 網路卡來傳輸PPP 協定的資料。由於PPPoA 使用於ATM 網路，所以也稱為PPPoATM。</description></item><item><title>ping 指令</title><link>https://cch0124.github.io/blog/2017-01-16-ping/</link><pubDate>Mon, 16 Jan 2017 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2017-01-16-ping/</guid><description>ping 是網路上常見的診斷工具。
用來判斷網路是否可連線 是否有設備連接 ping 是網路中必要的工具。
以下會介紹 ping 的使用以及 ICMP 協定。
ping work 發送 ICMP(Internet Control Message Protocol) 封包至目的端，最後的訊息可以判斷網路狀態的優良。 ICMP 主要用於確定數據是否及時到達預定目的地。當兩個設備透過 Internet 連線時，如果任何數據未到達其預期目的地，則 ICMP 會生成錯誤回傳。常用的終端應用程式 traceroute 和 ping 都使用 ICMP 進行操作。
ping [options] [destination] ping options
-c 指定要發送的 packet 數量 -s 更改 packet 的大小 -v 詳細訊息 -w 指定命令執行結束的時間（以秒為單位）無論命令發送或接收的 packet 數量 -i 可以指定要使用的網路介面 ping destination</description></item><item><title>ARP Protocol</title><link>https://cch0124.github.io/blog/2016-10-02-arp/</link><pubDate>Thu, 12 May 2016 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2016-10-02-arp/</guid><description>ARP 從本地端電腦傳送封包到你瀏覽的網頁，他會利用 IP Address 把封包傳送至目的地。但，這之間會學習到目的地 Host 的 MAC Address（Media Access Control Address），這樣才能達到準確溝通。在 Ethernet（乙太網路）環境下，Ethernet進行了連線、傳遞訊號等。要用 IP Address 找出 MAC 得要用 ARP（Address Resolution Protocol） ，ARP 屬於 OSI Model 網路層。
ARP 學習 當 R1 想找 PC1，但 R1 什麼都不知道，只認識自己。R1 發送 broadcast 發出一個 ARP Request，ARP Request 包含了PC1 的 IP Address 等，到了 Switch1 進行 flooding 使每個目的端 Host 都接收（因為是 broadcast）。接著，目的端都接收，會進行 ARP reply 的動作，只有符合 R1 要找的 IP 才會進行回覆以 unicast 方式，其餘的 Host 會把此 frame Drop 掉，之後 R1 會把找到的 Host MAC 給記錄到 ARP 表格。</description></item><item><title>IP Routing</title><link>https://cch0124.github.io/blog/2016-04-12-ip-routing/</link><pubDate>Tue, 12 Apr 2016 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2016-04-12-ip-routing/</guid><description>IP Routing 簡易來說就是我們從台灣主機到美國 google 主機，所經過的路徑過程。過程之間都是透過路由器的決策來完成。路由器會得知目的地 IP，藉由路由表決定下一跳的路徑，接著轉發封包。
假設 TW 想要取得 Google 的資訊，但是 Google 在跟 TW 不同的網路上。TW 會發送封包至路由器，路由起接收到封包後，會得知目的地 IP 位址，並對照路由表做決策再將 TW 發送至路由器的封包轉發到跟目標網路關聯的介面，最後抵達 Google。
Gateway 本地端主機要和遠方的主機通訊。當主機沒有遠方的主機路由資訊時，會發送至 Gateway。該 Gateway 的路由器會再做決策。
如上面的圖
TW 設置有路由器其中一個介面的 IP，TW 嘗試與遠方不同網路的 google 通訊。TW 在路由表中查找目標網路是否有路徑可到達。如果未找到該路徑，則 TW 將封包發送至路由器上的 TW Gateway IP。路由器接收風包後並將封包轉發給 google。
Routing Table 路由器會維護一個路由表並儲存在 RAM 中。路由器使用路由表來確定到目標網路的路徑。 每個路由表包含以下資訊：
R1#show ip route Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2 E1 - OSPF external type 1, E2 - OSPF external type 2 i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2 ia - IS-IS inter area, * - candidate default, U - per-user static route o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP + - replicated route, % - next hop override Gateway of last resort is not set 192.</description></item><item><title>子網路切割</title><link>https://cch0124.github.io/blog/2016-03-30-subnetting/</link><pubDate>Wed, 30 Mar 2016 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2016-03-30-subnetting/</guid><description>子網路 子網路劃分將網路切成多個小規模的網路，以提高路由效率、增強網路管理的安全也減小了廣播的功能。
如下示意圖
假設在一層大樓中，有分軟體部門、硬體部門、UI/UX 部門，將所有主機都分配至 192.168.0.0/24 子網路中。缺點會有以下：
廣播域問題 所有主機都在同一個廣播域中。所有主機都將處理網路上任何設備發送的廣播。應該要讓硬體部門的網路流量不影響其它部門，這樣可以提升效能。 網路上的安全 每個設備都可以訪問子網上的任何其他設備，這可能會帶來安全問題。例如，軟體部門有敏感訊息的服務將與其它的部門工作站位於同一網路中。 組織問題 部門盡量不要在同一子網路中 規劃之後
在規劃之後每個部門分配在不同子網中也位於不同的廣播域。</description></item><item><title>交換器基本介紹</title><link>https://cch0124.github.io/blog/2016-03-28-switch/</link><pubDate>Mon, 28 Mar 2016 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2016-03-28-switch/</guid><description>Switch 在網路設備中負責轉發網路封包。但，轉發這動作之前，Switch 也必須知道封包轉發的目的地以及要從哪一個埠轉發出去。
Switch 主要功能 能夠增加網路的可用頻寬 製作出 MAC table 分析其中的來源端與目的端的 MAC 位址 藉由 MAC table 正確的轉發網路封包 擁有較高速的內部結構 擁有比較多的埠介面 跟傳統的閘道器（Bridge）比較起來，交換器能夠提供更多的網路流量 MAC 位址學習 Switch 會從它們的埠上監聽所傳進來的 Frame（經過交換器的網路封包稱之為 Frame），檢測這些資料的來源端 MAC 位址，並且把 MAC 位址與埠號的對應關係記錄下來，儲存在本地端的 MAC Address Table 或是 Content-addressable Memory (CAM) Table。 當 Switch 再次收到 Frame，會先至 MAC Address Table 中察看哪個埠可以轉發至目的地 MAC 位址，如果有在 MAC Address Table，則這 Frame 會從學習到的埠轉發出去，否則這 Frame 會從除了來源埠之外的埠轉發出去。
當 Switch 收到 Frame 之後，一定會從所有其他的埠轉發出去，除了來源埠之外。這種轉發到除來源埠以外的其他埠的動作，稱為「Flooding」。用這種 Flooding 的動作來轉送Frame 很沒有效率，因為會浪費很多網路頻寬。
Switch 傳送 Frame 的模式 Store and Forward 交換器會先把 Frame 完整地接收下來，然後才進行轉發的動作 來源端及目的端的 MAC 位址都能夠被讀取 CRC（Cyclic Redundancy Check）錯誤檢查動作會被執行 檢查失敗，Frame 會被遺棄 確保 Frame 中資料的正確性 較費時 延遲時間與 Frame 的資料長度有關 Cut-Though 雖然有些交換器在這種模式下只想讀取 MAC 位址，但還是有某些交換器會讀取 CRC 值並記錄下錯誤數目。</description></item><item><title>路由器基本介紹</title><link>https://cch0124.github.io/blog/2016-03-22-router/</link><pubDate>Tue, 22 Mar 2016 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2016-03-22-router/</guid><description>Router 介紹 Routing 是決定網路封包要如何送往外部網路到達目的地的過程 Router 會取得達到路由所必須的資訊，並加以維護，而為了取得並維護這樣的路由資訊，必須使用路由協定 最主要的工作是決定要將網路封包送往何處 為了要讓封包送往目的地，必須學習以下
知道目的端的位址在哪裡 標示出來源端的位址，並把它學習起來 尋找這個封包可能要送往的路徑有哪些 從可能的路徑中選出最佳路徑 維護並更新這些路由所需的資料 Switch 也可以把封包轉發到目的地，它與 Router 運作方式不同。
路由器轉發封包決定方式 根據 Routing Table 的資料來決定如何轉發資料封包
Static Route 手動輸入 速度快 不須要經過學習 網路拓樸若有任何的改變，管理人員必須更新這些資料到路由器設備中 比較適合幾乎不會有變動的網路拓樸 Dynamic Route 不須要手動輸入 路由器設備之間去協調 互相交換並學習這些資料 只要做 Routing Protocol 的設定 較耗費系統資源，速度也稍微慢 系統需要時間去做學習的動作 需要一點時間才能把 Routing Table 建立得比較完整\ 網路架構有任何的改變，路由設備會自我學習維護 Routing Table Administrative Distance 來決定每一種不同路由協定的可靠程度 AD 值是一個從 0～255 的整數，每一種路由協定都有一個 AD 值與之對應 其值越低，代表可靠程度越高 路由方式對應 AD 值 路由方式 AD 預設值 直連 0 靜態路由 1 EIGRP Summary Route 5 外部 BGP 20 EIGRP 90 IGRP 100 OSPF 110 RIPv1、RIPv2 120 EGP(Exterior Gateway Protocol) 140 External EIGRP 170 Internal BGP 200 DHCP-learned 254 未知 255 Autonomous System 自治系統（Autonomous System）簡稱 AS，所有處於同樣管理網域（Administrative Domain）下所有網路的集合</description></item><item><title>CDP</title><link>https://cch0124.github.io/blog/2018-08-19-cdp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2018-08-19-cdp/</guid><description>CDP 在規劃一個網路架構時，如果不小心失去網路架構的資訊，應該會造成管理上的混亂，如果該環境設備都是 Cisco 設備，則可透過 CDP 協定探索收集到全部 Cisco 網路設備的軟硬體資訊，立即重建網路拓樸資訊。
利用 CDP 協定交換資訊 Cisco 網路設備會定期與周遭的 Cisco 網路設備進行資訊交換的動作，要達到這樣定期的資料交換動作，就必須透過 CDP 協定才行。CDP（Cisco Discovery Protocol）是 Cisco 的專利，運行於 OSI 七層協定之中第二層 Data Link Layer 的協定。可以透過它來讓設備相互收集設備的資訊，如：ISO 版本、IP 位址等。
CDP 協定所提供的資訊 設備ID 設備的名稱 第三層的IP位址清單 來源端和目的端埠名稱，例如：ethernet0 埠的ID 所支援的功能列表 硬體平台 硬體型號 關閉或開啟 CDP 協定的指令 以下範例拓樸圖
開啟或關閉 CDP R1(config)#no cdp run R1(config)#cdp run 關閉或重啟某介面的 CDP R1(config-if)#no cdp enable R1(config-if)#cdp enable CDP 協定的設定方式 顯示CDP協定資訊的指令 Cisco 路由器上的 CDP 協定可以開啟或關閉，預設為開啟。</description></item><item><title>NAT</title><link>https://cch0124.github.io/blog/2019-10-12-nat-dynamic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2019-10-12-nat-dynamic/</guid><description>什麼是 NAT 因為 IPv4 的地址將用盡，如果沒有 NAT 技術的話將導致某一些人無法存取網路。在 ISP 提供的 IP 可分為，動態 IP 與靜態 IP。動態 IP 可以想成從 ISP 那邊自動獲取 IP 類似於 DHCP；靜態 IP 就是給一個 Global IP 位置且它是收費的。隨著物聯網裝置的需求想必 IPv4 是不夠用，因此就有 NAT 去提升效率，藉由一個 Global IP 來對其下的組織或客戶端實現 NAT 並存取網際網路。
NAT 通常會配置兩個網路，該 NAT 可以隱藏內部訊息，其流程大致上是把私有 IP 轉換為 Global IP，在將其封包轉發至目的地，這樣也就提供對內的安全性。
NAT 可以幫忙解決 IPv4 不足問題也可以有隱藏 IP 功能提高安全性。但它也會有一些缺點，像是要保留傳入與傳出的 IPv4 這將對記憶體或 CPU 帶來負擔，因為多了 NAT 轉換想必延遲一定會有，除此之外它變得不可追溯，因此在做除錯時會帶來麻煩。
環境設置 下圖為實驗環境，兩台客戶端和一台可通往 Cloud1 的 ISP。
兩台客戶端使用 Vmware 虛擬機網路都為同一個 host only，接著用 netplan 配置虛擬機 IP 和 gateway，這 gateway 將會是 R1 的 f0/0 接口的 IP，這邊有 netplan 教學鏈結。圖中的 Cloud1 使用 Vmware 提供的可上網的網路適配器，記住上圖的 IP 設置應當依照實驗環境而設置。</description></item><item><title>Static NAT</title><link>https://cch0124.github.io/blog/2019-10-13-static-nat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2019-10-13-static-nat/</guid><description>環境 配置一台 host only 的虛擬機和一台 R1 路由器以及可以連至網際網路的 Cloud1。該 Cloud1 使用的是手機 USB 出來的網路適配器。
配置 R1 配置 f0/0 的 IP，對於這個 f0/0 來說它是虛擬機的 gateway，只要封包不知道要往哪邊走都會網 f0/0 丟。
R1(config)#interface fastEthernet 0/0 R1(config-if)#ip address 192.168.245.254 255.255.255.0 R1(config-if)#no shutdown 配置 R1 的 Outside 接口，使用 DHCP 方式向 Cloud1 請求 IP。
R1(config)#interface fastEthernet 1/0 R1(config-if)#no shutdown R1(config-if)#ip address dhcp 確認有無配置到 IP。
R1(config-if)#do sh ip int brief Interface IP-Address OK? Method Status Protocol FastEthernet0/0 192.168.245.254 YES manual up up FastEthernet1/0 192.</description></item></channel></rss>