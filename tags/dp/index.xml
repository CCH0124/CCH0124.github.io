<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dp on</title><link>https://cch0124.github.io/tags/dp/</link><description>Recent content in dp on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 13 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://cch0124.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 5. Longest Palindromic Substring</title><link>https://cch0124.github.io/code/2020-12-13-longestpalindromicsubstring/</link><pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-13-longestpalindromicsubstring/</guid><description>題目 5. Longest Palindromic Substring，這題一開始沒想出來解法，但是是知道回文規則。看了影片和一些參考資料才知道使用 DP 的原理。
class Solution { public String longestPalindrome(String s) { if (s.length() == 1) return s; if (s.length() == 2 &amp;amp;&amp;amp; s.charAt(0) == s.charAt(1)){ return s; } int start = 0; int end = 0; boolean [][] dp = new boolean[s.length()][s.length()]; // 自己和自己是回文 for (int i=0; i&amp;lt;dp.length; i++){ dp[i][i] = true; } // 相鄰的字元相同也是回文 for (int i = 0; i &amp;lt; s.length()-1; i++) { if (s.</description></item><item><title>LeetCode 62. Unique Paths and 63. Unique Paths II</title><link>https://cch0124.github.io/code/2020-12-12-uniquepaths/</link><pubDate>Sat, 12 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-12-uniquepaths/</guid><description>題目 62 與 題目 63 是相似的問題，後者多了障礙物的設計。思路就是利用動態規劃，其中當前位置會是左邊與上面的能夠抵達方式的相加，因為題目限制往右和往下走。
題目 62
class Solution { public int uniquePaths(int m, int n) { int [][] dp = new int[m][n]; for(int i=0; i&amp;lt;m; i++){ for(int j=0; j&amp;lt;n; j++){ if( i == 0 || j == 0 ) { dp[i][j] = 1; } else { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } } return dp[m-1][n-1]; } } 題目 63，相較於 62 多了很多比較。我們把障礙物的當前能夠抵達次數設為 0，其做相加時不影響結果。接著起點做個判斷，非障礙物將其設為 1 以進行後續計算，在邊緣的地方有可能存在障礙物，因此不能像題目 62 一樣直接都設為 1。</description></item><item><title>LeetCode 64. Minimum Path Sum</title><link>https://cch0124.github.io/code/2020-12-12-minimumpathsum/</link><pubDate>Sat, 12 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-12-minimumpathsum/</guid><description>題目 64. Minimum Path Sum 尋找最少的路徑成本從起始點 (0,0) 到最右右下角，相似於題目 62 和 63。同樣的期限制是向右和向下。
class Solution { public int minPathSum(int[][] grid) { for(int i=0; i&amp;lt;grid.length; i++){ for(int j=0; j&amp;lt;grid[0].length; j++){ if ( i == 0 &amp;amp;&amp;amp; j == 0){ continue; } if (i == 0){ grid[i][j] = grid[i][j]+grid[i][j-1]; } else if (j == 0){ grid[i][j] = grid[i][j]+grid[i-1][j]; } else { grid[i][j] = Math.min((grid[i][j] + grid[i][j-1]), (grid[i][j] + grid[i-1][j])); } } } return grid[grid.length-1][grid[0].length-1]; } } 例子</description></item></channel></rss>