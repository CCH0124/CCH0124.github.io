<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>spring boot on</title><link>https://cch0124.github.io/tags/spring-boot/</link><description>Recent content in spring boot on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 27 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cch0124.github.io/tags/spring-boot/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring boot Web 開發 - Error Handler</title><link>https://cch0124.github.io/code/2021-10-27-error-handler-spring-boot/</link><pubDate>Wed, 27 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-27-error-handler-spring-boot/</guid><description>從官方介紹內容來看錯誤處理內從大概是以下
默認規則 預設下，Spring boot 提供 /error 處理所有錯誤的映射 對於非瀏覽器類型，會以 JSON 進行回應，其中包含錯誤、HTTP 狀態和異常訊息；對於瀏覽器則會以 whilelabel 進行視圖回應，會以 HTML 方式呈現 要自定義，添加 View 解析為 Error 要完全替代預設的行為，可以實作 ErrorController 並註冊該類型的 Bean 定義，或添加 ErrorAttributes 類型的組件以替換內容 異常整體流程處理
執行目標方法，只要期間有錯誤都會被 JAVA 的 catch 語法給抓到，並將當前請求結束，其過程會進入 dispatchException 進入 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException) 當中 mv = processHandlerException，處理 handler 發生的異常，接著回傳 ModelAndView，過程會遍歷 handlerExceptionResolvers，看誰能處理，系統默認的解析起有以下 DefaultErrorAttributes 先來處理異常。把異常訊息給 request，並返回 null HandlerExceptionResolveComposite ExceptionHandlerExceptionResolver ResponseStatusExceptionResolver DefaultHandlerExceptionResolver 預設下沒有東西可以處理異常，因此異常被拋出，最後發送 /error 請求，被底層 BasicErrorController 處理。 定制錯誤邏輯 自定義錯誤頁面 在 error 目錄下進行匹配 @ControllerAdvice+@ExceptionHandler 底層是 ExceptionHandlerExceptionResolver @ResponseStatus+自定義異常 底層是 ResponseStatusExceptionResolver，把 @ResponseStatus 註解訊息底層調用 response.</description></item><item><title>lombok 利器</title><link>https://cch0124.github.io/code/2021-10-17-lombok/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-17-lombok/</guid><description>maven 引用 Lombok 方式
&amp;lt;dependencies&amp;gt; ... &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.18.20&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; ... &amp;lt;/dependencies&amp;gt; 在 Spring boot 中預設也將 lombok 作為套件，從下面範例來看我們透過 @Data 自動生成 get、set 方法；@ToString 產生 toString() 方法；透過 @AllArgsConstructor 產生有參數的建構方法，相反的使用 @NoArgsConstructor 則為無參數。使用 @EqualsAndHashCode 幫我們重寫 HashCode 和 equals。透過 @Slf4j 則會幫我們注入 Log 相關的操作。
@Data @ToString public class Car { private String brand; private Integer price; } 當要使用並構建一個物件時都需要
Product product = new Product(); product.setPrice(100); product.setName(&amp;#34;Apple&amp;#34;); 但藉由 @Builder 的註解，可以省下一些細節
Product product = Product.builder() .price(100) .name(&amp;#34;Apple&amp;#34;) .</description></item><item><title>Spring boot Web 開發</title><link>https://cch0124.github.io/code/2021-10-17-spring-boot-web/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-17-spring-boot-web/</guid><description>Spring boot provides auto-configuration for Spring MVC that works well with most applications.
請求參數處理 請求映射 RequestMapping value 請求路徑 method 使用的 HTTP Method @RequestMapping(value=&amp;#34;path&amp;#34;, method=RequestMethod.GET) public SomeData requestMethodName(@RequestParam String param) { return new SomeData(); } 在 Spring boot 中以下的請求映射都繼層於 RequestMapping
GetMapping PostMapping DeleteMapping PutMapping DispatcherServlet 是處理所有請求的開始，往上追最後會繼層一個 HttpServlet，當中請求會調用 doGet 方法（如果是 Get 請求），在 DispatcherServlet 中所有請求都會調用 doDispatch(HttpServletRequest request, HttpServletResponse response)。所有請求都存在於 HandlerMapping 中在 Spring boot 中有 5 種，Spring boot 自動配置歡迎頁面的 WelcomePageHandlerMapping，只要請求訪問 / 能訪問到 index.</description></item><item><title>Spring boot 概觀</title><link>https://cch0124.github.io/code/2021-10-17-spring-boot/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-17-spring-boot/</guid><description>Spring 能做什麼 Microservice Reactive Cloud Web apps Serverless FaaS Event Driven Batch Spring 生態圈很大。包含以下
Spring Framework DI AOP Spring Data 數據操作部分 Spring Cloud Spring Security Spring Session Spring boot 底層是 Spring Framework。Spring5 後有了變化，有了 spring reactive JAVA 8 的特性也改變底層的實現原理，像是預設的 interface。
什麼是 Spring boot Spring boot makes it easy to create stand-alone, production-grade Spring based Application that you can &amp;ldquo;just run&amp;rdquo;.</description></item><item><title>單元測試</title><link>https://cch0124.github.io/code/2021-09-06.junit5/</link><pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-09-06.junit5/</guid><description>Junit5 是目前最新的框架，其由三個模組組成
JUnit Platform 在 JVM 上啟動測試框架的基礎，在 Junit 之外的框架都能接入 JUnit Jupiter Junit5 的核心，內部包含了一個測試引擎，用於在 JUnit Platform 上運行 JUnit Vintage &amp;hellip; ___________________________________________________________________________________________________________________________________ | | | | | Junit5 | | ________________________ ________________________ ________________________ | | | | | | | | | | | | | | | | | | | JUnit Platform | + | JUnit Jupiter | + | JUnit Vintage | | | | | | | | | | | |_______________________| |_______________________| |_______________________| | | | | | | | | | |__________________________________________________________________________________________________________________________________| Srping boot 2.</description></item><item><title>Camel 概觀</title><link>https://cch0124.github.io/blog/2022-05-01-camel/</link><pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2022-05-01-camel/</guid><description>Camel 對於 Java 來說是一個整合函式庫，期提供 API 使你可以整合不同的來源數據，Camel 可以說是不同數據之間的膠水，從一個應用程式獲取數據，並透過管道傳輸到另一個應用程式，該過程可以轉換、變更。
當有資源需要從 A 到 B 或許 Camel 是一個好的整合工具，其場景可能是
發送 Mail 地端資料送到雲端硬碟 從 AWS SQS 獲取訊息，再調用我們自己 API XML 轉 CSV 從資料庫獲取資料 等等 Camel 有以下核心元件
Camel Core 包含 Camel APIs、Camel runtime engine、Camel 應用程式運行時管理的功能 Component JARs 每個組件擴展了 Camel 與第三方系統或 API 交互的功能 Platform support JARs 提供 Camel 在不同平台上運行的功能 下圖是 Camel 概念圖 Camel 提供 runtime engine，他叫 Camel Context，負責運行 Camel 整合。</description></item><item><title>Spring Boot JPA Note</title><link>https://cch0124.github.io/blog/2020-12-08-jpa-note/</link><pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2020-12-08-jpa-note/</guid><description>JPA 基本註解 @Entity 用於實體類的聲明，指出該類為實體類，將其映射至指定的資料表上。配合著 @Table 註解可以聲明該數據表的名稱，否則預設以類名稱命名。
@Id 將屬性映射為主鍵列。會配合 @GeneratedValue 來定義主鍵產生的策略，透過 strategy 進行設定，有以下方式
IDENTITY AUTO JPA 自動選擇合適的策略 默認值 SEQUENCE TABLE @Basic 屬性到數據表中的字段映射，默認都會有此註解。
@Column 可用來約束該屬性對應到數據表中的屬性功能，像是 unique、nullable、length 等。
@Transient 表示該屬性並非一個要映射到數據表的字段。
@Temporal 在 JAVA API 中無定義 Date 類型的精度。在資料庫中表示 Date 類型方式有 DATE、TIME、TIMESTAMP 三種精度。因此可藉由此註解調整精度。</description></item></channel></rss>