<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on</title><link>https://cch0124.github.io/tags/leetcode/</link><description>Recent content in LeetCode on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 12 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cch0124.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 268 Missing Number</title><link>https://cch0124.github.io/code/2021-01-12-missing-number/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-01-12-missing-number/</guid><description>Missing Number 題目 找出陣列中缺少的數值。思路利用數組長度帶入梯形公式算出3整個序列之和再減去目前數組中所有數值之和，即可獲取答案。
class Solution { public int missingNumber(int[] nums) { int len = nums.length; int trape = (0 + len)*(len+1)/2; int sum = Arrays.stream(nums).sum(); return trape - sum; } }</description></item><item><title>LeetCode Contains Duplicate I and II</title><link>https://cch0124.github.io/code/2021-01-02-contains-duplicate/</link><pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-01-02-contains-duplicate/</guid><description>Contains Duplicate 題目 217，檢查數組中是否有相同的值。思路一使用 Hash 方式，如果出現相同值 Hash 值會撞，如果撞表示是重複值。思路二使用 Set 不存放相同的值，最後比較 Set 存放的元素個數使否小於原始數組元素個數。
class Solution { public boolean containsDuplicate(int[] nums) { HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;nums.length; i++){ if (map.containsKey(nums[i])){ return true; } else { map.put(nums[i], 1); } } return false; } } class Solution { public boolean containsDuplicate(int[] nums) { Set&amp;lt;Integer&amp;gt; set = Arrays.stream(nums).boxed().collect(Collectors.toSet()); return set.size() &amp;lt; nums.length; } } Contains Duplicate II 題目 219，相較於第一版則是多了一個條件，把出現重複的值其所在的元素位置進行相減，並且要小於或等於給定的 k。這邊延伸第一版的程式碼，只是多了位置的判別。
class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i=0; i&amp;lt;nums.</description></item><item><title>LeetCode Best Time to Buy and Sell Stock I and II</title><link>https://cch0124.github.io/code/2020-12-31-best-time-to-buy-and-sell-stock/</link><pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-31-best-time-to-buy-and-sell-stock/</guid><description>Best Time to Buy and Sell Stock I 題目說明，如果只允許最多完成一筆交易，找到最大的利潤。也就是找到最大獲利的價差。
class Solution { public int maxProfit(int[] prices) { int min = Integer.MAX_VALUE; int max = 0; for (int i=0; i&amp;lt;prices.length; i++){ int price = prices[i]; if (price &amp;lt; min){ min = price; } else if (price - min &amp;gt; max) { max = price - min; } } return max; } } Best Time to Buy and Sell Stock II 題目說明，相較於第一版，這次是找出多筆交易中可獲利最大的價值。思路是，前後的價值為正數表示此交易有獲利，最後把這多筆的獲利相加。</description></item><item><title>LeetCode Pascal's Triangle I and II</title><link>https://cch0124.github.io/code/2020-12-26-pascals-triangle/</link><pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-26-pascals-triangle/</guid><description>Pascal&amp;rsquo;s Triangle 題目，思路就是動態規劃的概念。
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generate(int numRows) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); if (numRows == 0) return res; List&amp;lt;Integer&amp;gt; base = new ArrayList&amp;lt;&amp;gt;(); base.add(1); res.add(base); for (int i=1; i&amp;lt;numRows; i++){ List&amp;lt;Integer&amp;gt; row = new ArrayList&amp;lt;&amp;gt;(); row.add(1); for(int j=1; j &amp;lt; i; j++){ row.add(res.get(i-1).get(j) + res.get(i-1).get(j-1)); } row.add(1); res.add(row); } return res; } } Pascal&amp;rsquo;s Triangle II 題目相較於第一版本它是要取出某一列，概念上是相同。
class Solution { public List&amp;lt;Integer&amp;gt; getRow(int rowIndex) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; base = new ArrayList&amp;lt;&amp;gt;(); base.</description></item><item><title>LeetCode Two Sum I and II</title><link>https://cch0124.github.io/code/2020-12-25-two-sum/</link><pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-25-two-sum/</guid><description>Two Sum I 題目內容是說從給予的陣列中找出兩個索引值相加等於給定目標值。這邊使用 HashMap 的概念實現題目要求。
class Solution {s public int[] twoSum(int[] nums, int target) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int complement = target - nums[i]; if (map.containsKey(complement)) { return new int[] { map.get(complement), i }; } map.put(nums[i], i); } return new int []{}; } } Two Sum II 題目相較於第一版本對陣列進行排序。思路是使用兩個指針方式進行遍歷。
class Solution { public int[] twoSum(int[] numbers, int target) { int start = 0; int end = numbers.</description></item><item><title>LeetCode 2. Add Two Numbers</title><link>https://cch0124.github.io/code/2020-12-13-addtwonumbers/</link><pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-13-addtwonumbers/</guid><description>題目 2. Add Two Numbers，單純的將兩個鏈接做相加。須注意的是進位而已。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int carry = 0; ListNode dummy = new ListNode(0); ListNode cur = dummy; int l1Val = 0; int l2Val = 0; int sum = 0; while (l1 !</description></item><item><title>LeetCode 5. Longest Palindromic Substring</title><link>https://cch0124.github.io/code/2020-12-13-longestpalindromicsubstring/</link><pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-13-longestpalindromicsubstring/</guid><description>題目 5. Longest Palindromic Substring，這題一開始沒想出來解法，但是是知道回文規則。看了影片和一些參考資料才知道使用 DP 的原理。
class Solution { public String longestPalindrome(String s) { if (s.length() == 1) return s; if (s.length() == 2 &amp;amp;&amp;amp; s.charAt(0) == s.charAt(1)){ return s; } int start = 0; int end = 0; boolean [][] dp = new boolean[s.length()][s.length()]; // 自己和自己是回文 for (int i=0; i&amp;lt;dp.length; i++){ dp[i][i] = true; } // 相鄰的字元相同也是回文 for (int i = 0; i &amp;lt; s.length()-1; i++) { if (s.</description></item><item><title>LeetCode 62. Unique Paths and 63. Unique Paths II</title><link>https://cch0124.github.io/code/2020-12-12-uniquepaths/</link><pubDate>Sat, 12 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-12-uniquepaths/</guid><description>題目 62 與 題目 63 是相似的問題，後者多了障礙物的設計。思路就是利用動態規劃，其中當前位置會是左邊與上面的能夠抵達方式的相加，因為題目限制往右和往下走。
題目 62
class Solution { public int uniquePaths(int m, int n) { int [][] dp = new int[m][n]; for(int i=0; i&amp;lt;m; i++){ for(int j=0; j&amp;lt;n; j++){ if( i == 0 || j == 0 ) { dp[i][j] = 1; } else { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } } return dp[m-1][n-1]; } } 題目 63，相較於 62 多了很多比較。我們把障礙物的當前能夠抵達次數設為 0，其做相加時不影響結果。接著起點做個判斷，非障礙物將其設為 1 以進行後續計算，在邊緣的地方有可能存在障礙物，因此不能像題目 62 一樣直接都設為 1。</description></item><item><title>LeetCode 64. Minimum Path Sum</title><link>https://cch0124.github.io/code/2020-12-12-minimumpathsum/</link><pubDate>Sat, 12 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-12-minimumpathsum/</guid><description>題目 64. Minimum Path Sum 尋找最少的路徑成本從起始點 (0,0) 到最右右下角，相似於題目 62 和 63。同樣的期限制是向右和向下。
class Solution { public int minPathSum(int[][] grid) { for(int i=0; i&amp;lt;grid.length; i++){ for(int j=0; j&amp;lt;grid[0].length; j++){ if ( i == 0 &amp;amp;&amp;amp; j == 0){ continue; } if (i == 0){ grid[i][j] = grid[i][j]+grid[i][j-1]; } else if (j == 0){ grid[i][j] = grid[i][j]+grid[i-1][j]; } else { grid[i][j] = Math.min((grid[i][j] + grid[i][j-1]), (grid[i][j] + grid[i-1][j])); } } } return grid[grid.length-1][grid[0].length-1]; } } 例子</description></item><item><title>LeetCode 1306. Jump Game III</title><link>https://cch0124.github.io/code/2020-12-10-jumpgameiii/</link><pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-10-jumpgameiii/</guid><description>題目，會給一個起始點(start)，而這個起始點可以選擇對元素進行加或減，透過這種方式不斷進行，最後檢測有沒有辦法到達值 0 的元素。
思路就是要麻當前元素進行減或加，用遞迴方式不斷去求值。使用一個 boolean 的陣列記錄當前該位置是否訪問過。
class Solution { public boolean canReach(int[] arr, int start) { boolean [] vis = new boolean[arr.length]; return canReach(arr, start, vis); } private boolean canReach(int[] arr, int start, boolean[] vis){ if (start &amp;lt; arr.length &amp;amp;&amp;amp; start &amp;gt;= 0 &amp;amp;&amp;amp; !vis[start]){ if (arr[start] == 0){ return true; } vis[start] = true; return canReach(arr, start + arr[start], vis) || canReach(arr, start - arr[start], vis); } return false; } }</description></item><item><title>783. Minimum Distance Between BST Nodes</title><link>https://cch0124.github.io/code/2020-12-09-minimumdistancebetweenbstnodes/</link><pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-09-minimumdistancebetweenbstnodes/</guid><description>題目，找出兩節點最小差值，思路以中序概念來想，經過 BST 樹經過中序遍歷後其結果會是排序的樣子，因此我們只要當前的值和左邊的值進行相減逐一比較即可獲得答案。
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int res = Integer.MAX_VALUE; TreeNode node = null; public int minDiffInBST(TreeNode root) { if (root == null) return 0; minDiffInBST(root.</description></item><item><title>897. Increasing Order Search Tree</title><link>https://cch0124.github.io/code/2020-12-09-increasingordersearchtree/</link><pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-09-increasingordersearchtree/</guid><description>題目，以中序為概念。BST 樹經過中序後其最後會是排序結果。
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { TreeNode res = new TreeNode(0); TreeNode cur = res; public TreeNode increasingBST(TreeNode root) { if (root !</description></item><item><title>LeetCode 938. Range Sum of BST</title><link>https://cch0124.github.io/code/2020-12-09-rangesumofbst/</link><pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-09-rangesumofbst/</guid><description>題目，這一題會給 low 和 high，只要這棵樹的節點數值滿足大於等於 low 和小於等於 high 就將其相加並成為最後結果。思路是使用前序進行遍歷，並利用 BST 特性左小右大來決定下個節點是否要進行遞歸。
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int res = 0; public int rangeSumBST(TreeNode root, int low, int high) { if (root !</description></item><item><title>LeetCode 53. Maximum Subarray</title><link>https://cch0124.github.io/code/2020-12-08-maximumsubarray/</link><pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-08-maximumsubarray/</guid><description>題目，求連續最大子序列。這題配合著此youtube實作。透過各個擊破方式，增加程式運行效率。同時在進行切分時，有三種方案
左邊最大 右邊最大 中間往左和往右 其第三種會有同時跨佐和跨右問題，其解決辦法如下
class Solution { public int maxSubArray(int[] nums) { return maxSubArray(nums, 0, nums.length-1); } /** * case 1. left Max * case 2. right Max * case 3. mid Max **/ public int maxSubArray(int[] nums, int start, int end){ if(start == end){ return nums[start]; } int mid = (start + end)/2; return Math.max( Math.max(maxSubArray(nums, start, mid), maxSubArray(nums, mid+1, end)), MaxSubCrossArray(nums, start, mid, end) ); } /** * 中間往左和往右計算連續最大值，最後在與往左和往右相加進行比較 **/ public int MaxSubCrossArray(int[] nums, int start, int mid, int end){ int sum = 0; int left_sum = Integer.</description></item></channel></rss>