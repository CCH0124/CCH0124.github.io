<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring security on</title><link>https://cch0124.github.io/tags/spring-security/</link><description>Recent content in Spring security on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 02 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cch0124.github.io/tags/spring-security/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring security - CSRF(Cross-site request request forgery)</title><link>https://cch0124.github.io/code/2021-11-02-csrf/</link><pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-11-02-csrf/</guid><description>CSRF 原理網路上有很多解釋這邊不再進一步介紹，推薦cloudflare 所寫的內容。
在 Spring Security CSRF 會針對 PATCH、POST、PUT 和 DELETE HTTP 方法進行防護。在先前的範例中我們將 CSRF 關閉
.and().csrf().disable(); 只要將其拿掉即可開啟 CSRF 防護。
Spring Security CSRF 原理 從 CsrfFilter 類別中查看 doFilterInternal 方法，可以大致清楚知道它的處裡邏輯。
@Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { request.setAttribute(HttpServletResponse.class.getName(), response); CsrfToken csrfToken = this.tokenRepository.loadToken(request); boolean missingToken = (csrfToken == null); if (missingToken) { csrfToken = this.tokenRepository.generateToken(request); this.tokenRepository.saveToken(csrfToken, request, response); } request.setAttribute(CsrfToken.class.getName(), csrfToken); request.setAttribute(csrfToken.getParameterName(), csrfToken); if (!this.requireCsrfProtectionMatcher.matches(request)) { if (this.</description></item><item><title>Spring security - user logout 與自動登入</title><link>https://cch0124.github.io/code/2021-10-30-spring-security-user-logout/</link><pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-30-spring-security-user-logout/</guid><description>logout 以下是一個使用者登出後的配置，登出成功後頁面會跳轉到 /api/v1/index
@Override protected void configure(HttpSecurity http) throws Exception { // TODO Auto-generated method stub // logout http.logout().logoutUrl(&amp;#34;/logout&amp;#34;).logoutSuccessUrl(&amp;#34;/api/v1/index&amp;#34;).permitAll(); http.exceptionHandling().accessDeniedPage(&amp;#34;/403.html&amp;#34;); http.formLogin() // 自定義編寫登入頁面 ... } 撰寫一個登出頁面如下，同時也修改上面的 defaultSuccessUrl 配置將其換成 defaultSuccessUrl(&amp;quot;/success.html&amp;quot;)
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Success&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Success&amp;lt;/h1&amp;gt; &amp;lt;br&amp;gt; &amp;lt;a href=&amp;#34;/logout&amp;#34;&amp;gt;&amp;lt;b&amp;gt;logout&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 實驗過程可以請求 http://localhost:8080/login.html 會跳轉到 http://localhost:8080/success.html 此時可以進行頁面的 API 請求。
自動登入 要實現的話會將數據儲存自 cookie 與 database，並進行比對。整體架構如下
________________ _____________________________ | | _____________________________________ | | | | 1 | | 2 | | | |-----------&amp;gt;| UsernamePassworAuthenticationFilter|-----------&amp;gt;| | | | |____________________________________| | | | | | ___________________ | ________ | | | | RemeberMeService| | | | | browser | | |_________________| | 4 | | | | 3 | ___________________ | --------------&amp;gt; | DB | | |&amp;lt;-------------------------------------------------------------| | TokenRepository| | 13 | | | | | |_________________| | --------------&amp;gt; |________| | | | | | | _____________________________________ | | | | 11 | | | | ______________________ | | | | 12 | | 14 | | | |-----------&amp;gt;| RememberMeAuthenticationFilter |-----------&amp;gt;| | --------------&amp;gt;| UserDetailsService | |________________| |____________________________________| |____________________________| |_____________________| 初始請求</description></item><item><title>Spring security - annotation</title><link>https://cch0124.github.io/code/2021-10-29-spring-security-annotation/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-29-spring-security-annotation/</guid><description>註解是為了可以方便讓我們使用，以下將會介紹註解。實驗過程可藉由更改 commaSeparatedStringToAuthorityList 方法所傳遞的權限進行調整
List&amp;lt;GrantedAuthority&amp;gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&amp;#34;admins,ROLE_sale&amp;#34;); @Secured 判斷是否具有角色，有的話表示可以存取該方法，這邊匹配的角色需加上 **ROLE_**。在使用註解時須先開啟註解功能 @EnableGlobalMethodSecurity
@SpringBootApplication @EnableGlobalMethodSecurity(securedEnabled = true) public class Securitydemo01Application { public static void main(String[] args) { SpringApplication.run(Securitydemo01Application.class, args); } } 透過 @Secured 註解可讓該方法被限制只能是 &amp;ldquo;ROLE_sale&amp;rdquo; 或 &amp;ldquo;ROLE_manager&amp;rdquo; 才能存取。
@GetMapping(&amp;#34;/update&amp;#34;) @Secured(value = {&amp;#34;ROLE_sale&amp;#34;,&amp;#34;ROLE_manager&amp;#34;}) public String update() { return &amp;#34;Hello update&amp;#34;; } @PreAuthorize 進入該方法前的權限驗證，可將登入使用者的 roles/permissions 參數傳到方法中。同樣的要使用該註解必須啟用，在 @EnableGlobalMethodSecurity 添加 prePostEnable=true。
@GetMapping(&amp;#34;/preAuth&amp;#34;) @PreAuthorize(value = &amp;#34;hasAnyAuthority(&amp;#39;admins&amp;#39;)&amp;#34;) public String preAuth() { return &amp;#34;Hello preAuth&amp;#34;; } 其中 hasAnyAuthority 也可以是 hasAuthority、hasRole 或 hasAnyRole 等，以下整理了一張表</description></item><item><title>Spring security 概觀</title><link>https://cch0124.github.io/code/2021-10-28-spring-security-overview/</link><pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-28-spring-security-overview/</guid><description>在 Spring Security 主要核心功能是 Authentication(使用者認證) 和 Authorization(使用者授權)兩部份。
Authentication 使用者是否能訪問該系統，一般都是透過帳號和密碼進行確認。 Authorization 用戶是否有權限執行某個操作，也就是系統上會有很多角色分配給使用者，而這些使用者能操作的動作就對應到角色。 演示 pom.xml ... &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; ... 撰寫一個 controller @RestController @RequestMapping(&amp;#34;/api/v1&amp;#34;) public class TestController { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello() { return &amp;#34;Hello Security&amp;#34;; } } 對設計的 controller 進行請求 會發現會被導到一個登入頁面，這也可以表示 Spring Security 有被啟用。 預設的使用者是 user 密碼則會是在 console 中以 Using generated security password: d7ce1ace-a637-4896-8556-a531dedbab29 呈現。登入後即可呈現我們所請求的內容。
基本原理 Spring Security 和 iptable 一樣都是一串鏈連接起來的。下面會介紹較為重要的過濾器</description></item></channel></rss>