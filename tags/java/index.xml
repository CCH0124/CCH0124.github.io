<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JAVA on</title><link>https://cch0124.github.io/tags/java/</link><description>Recent content in JAVA on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 02 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cch0124.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode Contains Duplicate I and II</title><link>https://cch0124.github.io/code/2021-01-02-contains-duplicate/</link><pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-01-02-contains-duplicate/</guid><description>Contains Duplicate 題目 217，檢查數組中是否有相同的值。思路一使用 Hash 方式，如果出現相同值 Hash 值會撞，如果撞表示是重複值。思路二使用 Set 不存放相同的值，最後比較 Set 存放的元素個數使否小於原始數組元素個數。
class Solution { public boolean containsDuplicate(int[] nums) { HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;nums.length; i++){ if (map.containsKey(nums[i])){ return true; } else { map.put(nums[i], 1); } } return false; } } class Solution { public boolean containsDuplicate(int[] nums) { Set&amp;lt;Integer&amp;gt; set = Arrays.stream(nums).boxed().collect(Collectors.toSet()); return set.size() &amp;lt; nums.length; } } Contains Duplicate II 題目 219，相較於第一版則是多了一個條件，把出現重複的值其所在的元素位置進行相減，並且要小於或等於給定的 k。這邊延伸第一版的程式碼，只是多了位置的判別。
class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i=0; i&amp;lt;nums.</description></item><item><title>物件導向 01 - extends</title><link>https://cch0124.github.io/code/2020-12-17-oop-extends/</link><pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-17-oop-extends/</guid><description>繼承(extends) 好處是減少代碼冗余、增加覆用性、便於功能的擴展、多態性。子類繼承父類後，子類會獲取父類的結構、屬性、方法，如果為 private，因為封裝性影響，子類不能直接調用父類結構，需透過 getter 和 setter 進行操作。
子類繼承之後可以聲名自己持有的屬性和方法，實現功能擴展。在 JAVA 只支持單繼承和多層繼承，無多重繼承。一個類能被多個子類繼承，一個類只能有一個父類。
所有 java 類（除 java.lang.Object）直接會間接繼承 java.lang.Object 類
覆寫 (override) 回傳類型、方法名和參數個數需一致 回傳類型可以是該類型的子類 同名同參數方法要是非 static 實現重寫，否則為非重寫 子類重寫的方法權限修飾不小於父類被重寫的方法的權限 子類拋出的異常範圍不能大於父類 以繼承來說 B 繼承 A，只要 B 有覆寫 A 的相關方法，則建立物件時取得的是 B 的覆寫，否則就是 A 的。
super 用來調用以下
屬性
法
建構方法
在子類的方法或建構方法中，透過使用 super.屬性或 super.方法的方式，顯示的調用父類中聲明的屬性或方法，通常都省略
當子類和父類中定義同名屬性時，要從子類調用父類的屬性，則必須使用 super.屬性或 super.方法
在建構方法中使用 super(參數列表)
需再首行</description></item><item><title>物件導向 01 - 類的成員</title><link>https://cch0124.github.io/code/2020-12-17-oop-class/</link><pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-17-oop-class/</guid><description>OOP 學習 JAVA 的 Class 與 Class 中的成員 屬性 方法 建構方法 區塊 內部類 以下特徵 封裝 繼承 多態 抽象 Class 與 Object Class 為對事物的描述，一種抽象概念。Object 實際存在的個體，也稱實例(instance)。
以下為 Class 範例，當中會包含屬性與行為
class Person { // 屬性 String name; int age; // 行為 public void eat() { System.out.println(&amp;#34;吃飯&amp;#34;); } public void sleep() { System.out.println(&amp;#34;睡覺&amp;#34;); } public void say(String language) { System.out.println(&amp;#34;我使用&amp;#34; + language + &amp;#34;說話&amp;#34;); } } 當把人這抽象的事物給描述好後，要建立一個實際的實例。</description></item><item><title>物件導向 03 - Interface</title><link>https://cch0124.github.io/code/2020-12-17-oop/</link><pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-17-oop/</guid><description>static 編寫一個類時，只有透過 new 關鍵字才會產生出物件，此時系統才會分配記憶體空間給該物件，這樣才能供外部調用。但某些特定數據在記憶體空間只有一份。台灣是個國家名稱，每一個台灣人都共享此國家名稱，不必每一個人的實例都分配一個代表國家名稱的變量。
static 修飾的變量是共享的 因為 class 只會加載一次，則 static 變量在記憶體中也只會存在一份，存在方法區的靜態域 靜態方法中，只能調用靜態的方法或屬性，非靜態方法，既可調用非靜態的方法或屬性，也可以調用靜態的方法或屬性 在靜態方法內，不能使用 this、super 關鍵字，生命週期 操作靜態屬性的方法，通常設置為 static 工具類中的方法，習慣聲名為 static 靜態變數隨著類加載而加載，因此早於物件的建立 代碼塊 用來初始類和對象 有修飾的話只能用 static 比較 靜態代碼塊 內部可以有輸出句 隨著類加載而執行，且只執行一次 初始化類的訊息 如果一個類中定義了多個靜態代碼塊，則按照宣告先後順序執行 靜態代碼塊的執行要優先於非靜態代碼塊的執行 靜態代碼塊內只調用靜態的屬性、靜態的方法，不能調用非靜態的結構 非靜態代碼塊 內部可以有輸出句 隨著物件的創見而執行 每創建一個物件，就執行一次非靜態代碼塊 可以在創建對象時，隊對象的屬性等進行初始化 如果一個類中定義了多個非靜態代碼塊，則按照宣告先後順序執行 非靜態代碼塊內只調用靜態的屬性、靜態的方法，也能調用非靜態的結構 public class Person { String name; int age; static String des = &amp;#34;Hello&amp;#34;; public Person() { } public Person(String name, int age) { this.</description></item><item><title>scanner port</title><link>https://cch0124.github.io/project/2017-06-27-scanner-port-java/</link><pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/project/2017-06-27-scanner-port-java/</guid><description>import java.io.IOException; import java.net.ServerSocket; public class PortScanner{ public void scan(){ for(int i=1; i &amp;lt; 65535 ; i++ ){//port 是 0 - 65535 try{ ServerSocket ss = new ServerSocket(i);// ServerSocket(int port) 建構 }catch(IOException ex){// port 被占用則拋出例外 System.out.println(&amp;#34;Port: &amp;#34;+ i + &amp;#34; Occupied&amp;#34;); } } } public static void main(String[] args) { PortScanner pserver = new PortScanner(); pserver.scan(); } } // 在 TCP 協定中，埠號 0 是被保留的，不可使用。在 UDP 協定中，來源埠號是可以選擇要不要填上，如果設為 0，則代表沒有來源埠號。</description></item></channel></rss>