<!doctype html><html lang=en-us style=max-width:1000px;margin:auto><head><title>Kevin Blog</title><meta name=theme-color content><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta name=description content="Kevin learning"><meta name=author content="Kevin Chen"><meta name=generator content="aafu theme by Darshan in Hugo 0.83.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.15.2/css/all.css integrity=sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu crossorigin=anonymous><link rel=stylesheet href=https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css><link rel=stylesheet href="//fonts.googleapis.com/css?family=Didact+Gothic%7CRoboto:400%7CRoboto+Mono"><link rel=stylesheet href=/css/aafu_pinkish.css><link rel=stylesheet href=/css/aafu.css><script>var themeColor=document.querySelector("meta[name=theme-color]");window.onload=()=>{themeColor.content=getComputedStyle(document.body)["background-color"];let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")},window.onresize=()=>{let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")}</script></head><body class=container><main style="min-height:calc(100vh - 60px)"><div class="d-flex flex-row row p-2"><h3 class="main-menu mr-3"><a href=https://cch0124.github.io/>Home</a></h3><h3 class="main-menu mr-3"><a href=/blog>Blog</a></h3><h3 class="main-menu mr-3"><a href=/project>Project</a></h3><h3 class="main-menu mr-3"><a href=/life>Life</a></h3><h3 class="main-menu mr-3"><a href=/kubernetes>Kubernetes</a></h3><h3 class="main-menu mr-3"><a href=/code>Coding</a></h3></div><div class=mb-3><h1 class=top-h1 style=font-size:2.75em>kubernetes - day10</h1><p class=mb-1>August 31, 2020</p><p>&mdash;</p></div><div class=content><p>此篇分享是要說關於 POD 對象的生命週期，POD 對象從建立到終止退出為它們的一個生命週期。而在這之間可以透過 POD 的定義執行一些創建容器、初始化容器等操作。在 <code>openshift</code> 中提供該生命週期流程圖，如下所示</p><p><img src=https://i.imgur.com/Y1zhYv5.png alt></p><p>這邊使用 <code>openshift</code> 文章內容進行翻譯解釋其流程</p><ol><li>啟動其它容器之前，將啟動 <code>infra</code> 容器，以建立其它容器加入的名稱空間，依照此理解應該是指 <code>pause</code> 容器</li><li>用戶定義的第一個容器啟動是 <code>init</code> 容器，可將其用於 POD 範圍內的初始化</li><li><code>main</code> 容器和 <code>post-start hook</code> 同時啟動，在範例中為4秒鐘</li><li>在秒數為 7 時，再次按每個容器啟動 <code>liveness</code> 和 <code>readiness probes</code></li><li>在秒數為 11 時，當 POD 被終止時，執行 <code>pre-stop hook</code>，最後在寬限期後終止 <code>main</code> 容器</li></ol><h2 id=pod-定相>POD 定相</h2><p>不管 POD 是被手動建立、或是透過一些 POD 控制器建立，POD 應當處於以下幾個定相</p><ul><li><p>Pending</p><ul><li>API Server 創建了 POD 資源並存入 etcd 中，但它尚未被調度完成，或者仍處於從倉庫下載 image 的過程中</li></ul></li><li><p>Running</p><ul><li>POD 已經被調度到某節點，且所有容器已由 <code>kubelet</code> 創建</li></ul></li><li><p>Failed</p><ul><li>所有容器都已經終止，但至少有一個容器終止失敗，即容器返回了非 0 值得退出狀態或已被系統終止</li></ul></li><li><p>Succeeded</p><ul><li>POD 中所有容器都已經成功終止並且不會被重啟</li></ul></li><li><p>Unknown</p><ul><li>API Server 無法取得 POD 狀態，通常是與 <code>kubelet</code> 通訊時出錯</li></ul></li><li><p><a href=https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>官方 pod-phase</a></p></li><li><p><a href=https://www.openshift.com/blog/kubernetes-pods-life>openshift kubernetes-pods-life</a></p></li></ul><h2 id=pod-建立過程>POD 建立過程</h2><p>POD 是 K8s 中的一個核心元件，理解其建立過程對於系統上的運行有一定的幫助。這邊將利用下圖說明建立過程</p><p><img src=https://i.imgur.com/70aDBqb.png alt> from <code>https://blog.heptio.com/</code></p><ol><li>客戶端透過 <code>kubectl</code> 或其它 API，客户端提交 <code>POD</code> <code>Spec</code> 給 <code>API Server</code></li><li><code>API Server</code> 嘗試將 POD 對象相關訊息存入 <code>etcd</code> 中，待寫入操作執行完成，<code>API Server</code> 即回傳確認訊息至客户端</li><li><code>API Server</code> 開始反映 <code>etcd</code> 中的狀態變化</li><li>所有 <code>Kubernetes</code> 元件都使用 <code>watch</code> 機制来追蹤檢查 <code>API Server</code> 上相關的變化</li><li><code>scheduler</code> 透過其 <code>watcher</code> 觀察到 <code>API Server</code> 創建了新的 POD 對象，但尚未绑定至任何節點</li><li><code>scheduler</code> 幫 POD 對象選擇節點並將結果訊息更新至 <code>API Server</code></li><li>調度結果訊息由 <code>API Server</code> 更新至 <code>etcd</code>，而 <code>API Server</code> 也會反映此 <code>POD</code> 對象的調度結果</li><li>POD 被調度到的節點上的 <code>kubelet</code> 嘗試在節點上調用 <code>Docker</code>，並把容器結果狀態回傳至 <code>API Server</code></li><li><code>API Server</code> 將 <code>POD</code> 狀態訊息存入 <code>etcd</code> 中</li><li>在 <code>etcd</code> 確認寫入操作成功完成後，<code>API Server</code> 將確認訊息發送至相關的<code>kubelet</code>，事件將透過它被接受</li></ol><h2 id=pod-生命周期中的行為>POD 生命周期中的行為</h2><h3 id=init-container>Init Container</h3><p><code>main</code> 容器啟動之前要運行的容器，常用於為 <code>main</code> 容器執行一些預先操作。<code>init</code> 容器需要運行完成到結束，若 <code>init</code> 容器運行失敗，那 <code>K8s</code> 需要重啟它直到成功完成，若 <code>restartPolicy</code> 字段是 <code>Never</code>，則該 <code>init</code> 容器運行失敗時，不會被重啟。這在像是等待其它關聯的元件、從一些倉庫獲取配置等。此字段在 <code>spec</code> 中以 <code>initContainers</code> 列表方式定義。</p><h3 id=lifecycle-hook>Lifecycle Hook</h3><p>容器生命週期鉤子(lifecycle hook)使它能夠感知其自身生命周期管理中的事件，並在相應的時刻到来時運行由客戶端指定的處裡程序。<code>K8s</code> 提供兩種方式</p><ul><li>postStart<ul><li>於容器創建完成後立即運行的 <code>hook</code> 操作，不過 <code>K8s</code> 無法確保它一定會於容器中的<code>ENTRYPOINT</code> 之前運行</li></ul></li><li>preStop<ul><li>於容器終止操作之前立即運行的 <code>hook</code> 操作，它以同步的方式調用，因此在其完成之前會阻塞刪除容器的操作的調用</li></ul></li></ul><p>上面兩種方式定義於 <code>spec</code> 中 <code>lifecycle</code> 字段。</p><h3 id=container-probe>Container Probe</h3><p>容器探測(container probe)是 POD 生命周期中的一項任務，它是 <code>kubelet</code> 對容器周期性執行的健康狀態診斷，該操作由容器的處理器(handler)定義。<code>K8s</code> 定義了三種方式</p><ul><li>ExecAction</li><li>TCPSocketAction</li><li>HTTPGetAction</li></ul><p>這三種方式會回應以下三種狀態</p><ul><li>Success<ul><li>表示成功</li></ul></li><li>Failure</li><li>Unknown</li></ul><p><code>kubelet</code> 可在容器上執行下面兩種類型的檢測</p><ul><li>livenessProbe<ul><li>存活性探測</li><li>failureThreshold<ul><li>失敗閾值</li></ul></li><li>periodSeconds<ul><li>探測時間週期</li><li>規定 <code>kubelet</code> 要每隔幾秒執行一次 <code>liveness probe</code></li></ul></li><li>initialDelaySeconds<ul><li>告訴 <code>kubelet</code> 在第一次執行 <code>probe</code> 之前要的等待幾秒鐘</li></ul></li><li>並且容器將根據其 <code>restart Policy</code> 決定未來</li></ul></li><li>readinessProbe<ul><li>就緒性探測</li></ul></li></ul><h5 id=livenessprobe-example>livenessProbe Example</h5><p>此範例使用 <code>exec</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>labels</span>:
    <span style=color:#f92672>test</span>: <span style=color:#ae81ff>liveness-exec</span>
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>liveness-exec</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>containers</span>:
  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>liveness-demo</span>
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>busybox</span>
    <span style=color:#f92672>args</span>:
    - <span style=color:#ae81ff>/bin/sh</span>
    - -<span style=color:#ae81ff>c</span>
    - <span style=color:#ae81ff>touch /tmp/healthy; sleep 60; rm -rf /tmp/healthy; sleep 600</span>
    <span style=color:#f92672>livenessProbe</span>:
      <span style=color:#f92672>exec</span>:
        <span style=color:#f92672>command</span>:
        - <span style=color:#ae81ff>test</span>
        - -<span style=color:#ae81ff>e</span>
        - <span style=color:#ae81ff>/tmp/healthy</span>
      <span style=color:#f92672>initialDelaySeconds</span>: <span style=color:#ae81ff>5</span>
      <span style=color:#f92672>periodSeconds</span>: <span style=color:#ae81ff>5</span>
</code></pre></div><p>在這資源清單上，<code>POD</code> 中只有一個容器。<code>periodSeconds</code> 字段指定了 <code>kubelet</code> 應該每 5 秒執行一次存活探測(指的是 <code>livenessProbe</code> 字段)。 <code>initialDelaySeconds</code> 字段向 <code>kubelet</code> 在執行第一次探測前應該等待 5 秒。<code>kubelet</code> 在容器内執行 <code>test -e /tmp/healthy</code> 進行探测。如果執行成功且返回值為 <code>0</code>，<code>kubelet</code> 會認為此容器是健康存活的。如果返回非 <code>0</code> 值，<code>kubelet</code> 會終止此容器並重新啟動。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ kubectl describe pod/liveness-exec
....
Events:
  Type    Reason     Age   From                                               Message
  ----    ------     ----  ----                                               -------
  Normal  Scheduled  21s   default-scheduler                                  Successfully assigned default/liveness-exec to gke-cluster-1-default-pool-7dc8b11b-cxs1
  Normal  Pulling    19s   kubelet, gke-cluster-1-default-pool-7dc8b11b-cxs1  Pulling image <span style=color:#e6db74>&#34;busybox&#34;</span>
  Normal  Pulled     19s   kubelet, gke-cluster-1-default-pool-7dc8b11b-cxs1  Successfully pulled image <span style=color:#e6db74>&#34;busybox&#34;</span>
  Normal  Created    19s   kubelet, gke-cluster-1-default-pool-7dc8b11b-cxs1  Created container liveness-demo
  Normal  Started    19s   kubelet, gke-cluster-1-default-pool-7dc8b11b-cxs1  Started container liveness-demo
</code></pre></div><p>30 秒後</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ kubectl describe pod/liveness-exec
....
Events:
  Type     Reason     Age              From                                               Message
  ----     ------     ----             ----                                               -------
  Normal   Scheduled  73s              default-scheduler                                  Successfully assigned default/liveness-exec to gke-cluster-1-default-pool-7dc8b11b-cxs1
  Normal   Pulling    71s              kubelet, gke-cluster-1-default-pool-7dc8b11b-cxs1  Pulling image <span style=color:#e6db74>&#34;busybox&#34;</span>
  Normal   Pulled     71s              kubelet, gke-cluster-1-default-pool-7dc8b11b-cxs1  Successfully pulled image <span style=color:#e6db74>&#34;busybox&#34;</span>
  Normal   Created    71s              kubelet, gke-cluster-1-default-pool-7dc8b11b-cxs1  Created container liveness-demo
  Normal   Started    71s              kubelet, gke-cluster-1-default-pool-7dc8b11b-cxs1  Started container liveness-demo
  Warning  Unhealthy  3s <span style=color:#f92672>(</span>x2 over 8s<span style=color:#f92672>)</span>  kubelet, gke-cluster-1-default-pool-7dc8b11b-cxs1  Liveness probe failed:
</code></pre></div><p>再 30 秒後</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ kubectl describe pod/liveness-exec
...
Restart Count:  <span style=color:#ae81ff>1</span> <span style=color:#75715e># 被重啟一次</span>
...
</code></pre></div><p>詳細可參考以下官方文章</p><ul><li><a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>liveness and readiness</a></li><li><a href=https://k8smeetup.github.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>configure-liveness-readiness-probes</a></li></ul><h2 id=容器重啟策略>容器重啟策略</h2><p>此字段定義在 <code>spec</code> 中 <code>restartPolicy</code>，<code>POD</code> 可能會發生故障，而對這故障的 <code>POD</code> 要做重啟或是不做任何策略都是藉由 <code>restartPolicy</code> 定義。</p><ul><li>Always<ul><li>POD 對象終止就將其重啟，默認設定</li></ul></li><li>OnFailure<ul><li>僅在 POD 對象出現錯誤時方才將其重啟</li></ul></li><li>Never<ul><li>永不重啟</li></ul></li></ul><h2 id=pod-終止過程>POD 終止過程</h2><p>我們以下圖做說明</p><p><img src=https://i.imgur.com/bgrGO6k.png alt></p><ol><li>客戶端向 <code>API Server</code> 發送刪除 POD 的請求</li><li><code>API Server</code> 中的 <code>POD</code> 會隨著時間的推移而更新，在寬限期 30秒内（預設），POD 被視為 <code>dead</code></li><li>將 <code>POD</code> 標記為 <code>Terminating</code> 狀態</li><li>與上一步同時作用，<code>kubelet</code> 在監控到 <code>POD</code> 轉為 <code>Terminating</code> 狀態同時啟動 <code>POD</code> 關閉過程</li><li>與第三步一同運行，端點控制器(Endpoint controller)監控到 <code>POD</code> 的關閉行為時將期從所有匹配到此端點的 <code>Service</code> 資源的端點列表中移除</li><li>如果當前 <code>POD</code> 資源定義了 <code>preStop</code>，則在其標記為 <code>terminating</code> 後即會以同步的方式啟動運行，如果寬限期結束後，<code>preStop</code> 仍未執行完成，則第 2 步將被重新執行並額外取得一個 2 秒的寬限期</li><li><code>POD</code> 中的容器行程收到 <code>TERM</code> 訊號</li><li>寬限期結束後，若存在任何一個仍在運行的行程，那麼 <code>POD</code> 會收到 <code>SIGKILL</code> 訊號</li><li><code>Kubelet</code> 請求 <code>API Server</code> 將此 <code>POD</code> 資源的寬限期設置為 0 從而完成刪除作業</li></ol><blockquote><p>prtStop 只會在容器終止前被調用</p></blockquote><h2 id=參考資源>參考資源</h2><ul><li><a href=https://jimmysong.io/kubernetes-handbook/concepts/pod-lifecycle.html>pod-lifecycle</a></li><li>馬哥 Kubernetes</li></ul></div><div class="d-flex flex-row justify-content-around"><h3 class="mb-1 mt-1 text-left mr-4"><a href=/kubernetes/2020-08-30-label-selector/ title="kubernetes - day09"><i class="nav-menu fas fa-chevron-circle-left"></i></a></h3><h3 class="mb-1 mt-1 text-left ml-4"><a href=/kubernetes/2020-09-01-pod-resource-limit-request/ title="kubernetes - day11"><i class="nav-menu fas fa-chevron-circle-right"></i></a></h3></div></main><footer class="mt-2 mb-4 text-center"><span class=markdownify>short copyright message</span>
<span>&#183;
<i><a href=https://github.com/darshanbaral/aafu>aafu</a></i>
by
<a href=https://www.darshanbaral.com/>darshan</a></span></footer></body></html>