<!doctype html><html lang=en-us style=max-width:1000px;margin:auto><head><title>Kevin Blog</title><meta name=theme-color content><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta name=description content="Kevin learning"><meta name=author content="Kevin Chen"><meta name=generator content="aafu theme by Darshan in Hugo 0.83.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.15.2/css/all.css integrity=sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu crossorigin=anonymous><link rel=stylesheet href=https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css><link rel=stylesheet href="//fonts.googleapis.com/css?family=Didact+Gothic%7CRoboto:400%7CRoboto+Mono"><link rel=stylesheet href=/css/aafu_pinkish.css><link rel=stylesheet href=/css/aafu.css><script>var themeColor=document.querySelector("meta[name=theme-color]");window.onload=()=>{themeColor.content=getComputedStyle(document.body)["background-color"];let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")},window.onresize=()=>{let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")}</script></head><body class=container><main style="min-height:calc(100vh - 60px)"><div class="d-flex flex-row row p-2"><h3 class="main-menu mr-3"><a href=https://cch0124.github.io/>Home</a></h3><h3 class="main-menu mr-3"><a href=/blog>Blog</a></h3><h3 class="main-menu mr-3"><a href=/project>Project</a></h3><h3 class="main-menu mr-3"><a href=/life>Life</a></h3><h3 class="main-menu mr-3"><a href=/kubernetes>Kubernetes</a></h3><h3 class="main-menu mr-3"><a href=/code>Coding</a></h3></div><div class=mb-3><h1 class=top-h1 style=font-size:2.75em>kubernetes - day17</h1><p class=mb-1>September 7, 2020</p><p>&mdash;</p></div><div class=content><p><code>POD</code> 並非有持久性，可能出於各種原因重新調度 <code>POD</code>，像是失敗的 <code>liveness</code> 或 <code>readiness</code> 檢查，如果此時與 <code>POD</code> 通訊會怎樣？當 <code>POD</code> 重啟時，可能具有不同的 IP 地址。這就是為什麼有 <code>Service</code> 的資源，<code>Service</code> 用於為 <code>POD</code> 提供一個固定、統一的存取功能和負載均衡，同時在集群內部使用 <code>DNS</code> 實現服務發現，解決客戶端發現容器的問題。<code>Service</code> 和 <code>POD</code> 的 IP 只在 <code>Kubernetes</code> 集群内相互存取，無法直接干預外部流量的請求。而 <code>Kubernetes</code> 提供了一些方法像是 <code>hostPort</code>、<code>hostNetwork</code>、<code>NodePort</code> 或 <code>LoadBalancer</code> 等，而另一種 <code>Ingress</code> 則是資源第七層的均衡負載。<code>Service</code> 藉由規則去定義策略，最重要的是還是會藉由<em>標籤</em>去實現。</p><h2 id=service-資源>Service 資源</h2><p>上述描述的問題，是編排系統可能會遇到的問題。當 <code>POD</code> 在做伸縮的應用時或是重新調度，都有可能影響 <code>IP</code>，這會導致客戶端存取資源時會錯誤。為了解決此問題 <code>kubernetes</code> 提供了 <code>Service</code> 資源。前面也提到說 <code>Service</code> 還是會藉由<em>標籤</em>去實作，如下圖所示，同時 <code>Service</code> 也隱藏了真實處裡用戶請求的 <code>POD</code>。下圖的標籤選擇器有多個符合的後端，這會讓 <code>Service</code> 可以用負載均衡方式進行調度的處裡。</p><figure><img src=/images/k8s/K8s-service-label.jpg width=auto height=auto></figure><p><code>Service</code> 會提供給 POD 的存取等級，這取決於服務的類型，當前有三種類型：</p><ul><li>ClusterIP<ul><li>屬於集群內部，只有集群內部的資源可相互存取，默認選項</li></ul></li><li>NodePort<ul><li>為節點提供一個可訪問的 IP 與 Port</li></ul></li><li>LoadBalancer<ul><li>從雲提供商添加負載均衡器，將流量從服務轉發到服務中的節點</li></ul></li></ul><p>詳細可參考<a href=https://kubernetes.io/zh/docs/concepts/services-networking/service/#publishing-services-service-types>官網</a>。實際上 <code>Service</code> 並非直接與 <code>POD</code> 通訊，其之間還有叫 <code>Endpoints</code> 的資源，它是由 <code>IP</code> 地址和 <code>Port</code> 组成的，<code>Service</code> 會擁有這個資源是透過標籤選擇器匹配的 <code>POD</code> 取得，這部分 <code>K8s</code> 幫我們自動實現了。</p><h2 id=虛擬-ip-和-service-代理>虛擬 IP 和 Service 代理</h2><p>一個 <code>Service</code> 資源其實就是每個節點上的 <code>Iptables</code> 或 <code>ipvs</code> 規則，將到達 <code>Service</code> 的流量轉發至相對應的 <code>Endpoints</code>。而這如何將規則創建至 <code>Iptables</code> 或 <code>ipvs</code> 上呢？這就是 <code>kube-proxy</code> 的作用了，它會不斷監聽 <code>API Server</code> 中紀錄 <code>Service</code> 對應 <code>POD</code> 的資訊。</p><p><code>kube-proxy</code> 將請求代理到相對應的 <code>Endpoints</code> 有三種方式，描述是官方內容</p><ul><li>userspace<ul><li>多了用戶空間和內核空間之間切換</li></ul></li><li>iptables<ul><li>使用 <code>iptables</code> 處理流量具有較低的系統開銷，因為流量由 Linux <code>netfilter</code> 處理，而無需在用戶空間和內核空間之間切換。這種方法也可能更可靠</li></ul></li><li>ipvs<ul><li>與 <code>iptables</code> 模式下的 <code>kube-proxy</code> 相比，<code>IPVS</code> 模式下的 <code>kube-proxy</code> 重定向通訊的延遲要短，並且在同步代理規則時具有更好的性能。與其他代理模式相比，<code>IPVS</code> 模式還支持更高的網路流量吞吐量。</li></ul></li></ul><p>詳細的內容可參考<a href=https://kubernetes.io/zh/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>官方</a>解釋。</p></div><div class="d-flex flex-row justify-content-around"><h3 class="mb-1 mt-1 text-left mr-4"><a href=/kubernetes/2020-09-06-job-cronjob/ title="kubernetes - day16"><i class="nav-menu fas fa-chevron-circle-left"></i></a></h3><h3 class="mb-1 mt-1 text-left ml-4"><a href=/kubernetes/2020-09-08-service-ingress-part2/ title="kubernetes - day18"><i class="nav-menu fas fa-chevron-circle-right"></i></a></h3></div></main><footer class="mt-2 mb-4 text-center"><span class=markdownify>short copyright message</span>
<span>&#183;
<i><a href=https://github.com/darshanbaral/aafu>aafu</a></i>
by
<a href=https://www.darshanbaral.com/>darshan</a></span></footer></body></html>