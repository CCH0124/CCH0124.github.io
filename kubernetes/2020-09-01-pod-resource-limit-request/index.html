<!doctype html><html lang=en-us style=max-width:1000px;margin:auto><head><title>Kevin Blog</title><meta name=theme-color content><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta name=description content="Kevin learning"><meta name=author content="Kevin Chen"><meta name=generator content="aafu theme by Darshan in Hugo 0.83.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.15.2/css/all.css integrity=sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu crossorigin=anonymous><link rel=stylesheet href=https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css><link rel=stylesheet href="//fonts.googleapis.com/css?family=Didact+Gothic%7CRoboto:400%7CRoboto+Mono"><link rel=stylesheet href=/css/aafu_pinkish.css><link rel=stylesheet href=/css/aafu.css><script>var themeColor=document.querySelector("meta[name=theme-color]");window.onload=()=>{themeColor.content=getComputedStyle(document.body)["background-color"];let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")},window.onresize=()=>{let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")}</script></head><body class=container><main style="min-height:calc(100vh - 60px)"><div class="d-flex flex-row row p-2"><h3 class="main-menu mr-3"><a href=https://cch0124.github.io/>Home</a></h3><h3 class="main-menu mr-3"><a href=/blog>Blog</a></h3><h3 class="main-menu mr-3"><a href=/project>Project</a></h3><h3 class="main-menu mr-3"><a href=/life>Life</a></h3><h3 class="main-menu mr-3"><a href=/kubernetes>Kubernetes</a></h3><h3 class="main-menu mr-3"><a href=/code>Coding</a></h3></div><div class=mb-3><h1 class=top-h1 style=font-size:2.75em>kubernetes - day11</h1><p class=mb-1>September 1, 2020</p><p>&mdash;</p></div><div class=content><p>在 <code>K8s</code> 上，可經由容器或 POD 請求或使用的<em>計算資源</em>有記憶體和 <code>CPU</code>。相互比較的話前者為不可壓縮資源，做一些伸縮操作可能會有問題，而後者事可壓縮資源，可以做伸縮的操作。</p><p>資源隔離目前是屬於容器級別，而資源藉由 <code>requests</code> 定義請求的可最小可用值，另一個 <code>limits</code> 用於限制資源最大可用值，如下圖所示。在 <code>K8s</code> 上，一個單位的 CPU 相當於虛擬機上的一顆 <code>vCPU</code> 或實體機上的一個 <code>Hyperthread</code>(一個邏輯 <code>CPU</code>)，一個核心相當於 <code>1000</code> 個微核心所以<code>200m</code> 相當於 <code>0.2</code> 個核心。記憶體以 <code>Ei</code>、<code>Pi</code>、<code>Ti</code>、<code>Ki</code> 等單位作為計算。</p><p><img src=https://miro.medium.com/max/875/1*Ed6e9HnZSGKDS514It-cTA.png alt> from &ldquo;<a href=https://jaxenter.com/manage-container-resource-kubernetes-141977.html%22>https://jaxenter.com/manage-container-resource-kubernetes-141977.html"</a></p><h2 id=example>Example</h2><h5 id=requests>requests</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>stress-pod</span>
  <span style=color:#f92672>labels</span>:
    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>test</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>containers</span>:
  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>stress</span>
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>ikubernetes/stress-ng</span>
    <span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;/usr/bin/stress-ng&#34;</span>, <span style=color:#e6db74>&#34;-c 1&#34;</span>, <span style=color:#e6db74>&#34;-m 1&#34;</span>, <span style=color:#e6db74>&#34;--metrics-brief&#34;</span>]
    <span style=color:#f92672>resources</span>:
      <span style=color:#f92672>requests</span>:
        <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;128Mi&#34;</span>
        <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;200m&#34;</span>
</code></pre></div><p>配置清單上，<code>POD</code> 要求為容器要有 <code>128Mi</code> 記憶體和 5 分之 1 的 <code>CPU</code> 核心的最小資源。使用 <code>-m 1</code> 進行記憶體的壓測，滿載時盡可能占用 <code>CPU</code> 資源，同時間 <code>-c 1</code> 是對 <code>CPU</code> 進行壓測。</p><p>當上面的資源清單建立後，使用 <code>exec</code> 對容器執行 <code>top</code> 進行觀察。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ kubectl exec stress-pod -- top
Mem: 2067432K used, 1976380K free, 3496K shrd, 102096K buff, 962844K cached
CPU:  99% usr   0% sys   0% nic   0% idle   0% io   0% irq   0% sirq
Load average: 1.04 0.29 0.12 3/509 <span style=color:#ae81ff>13</span>
  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND
    <span style=color:#ae81ff>8</span>     <span style=color:#ae81ff>7</span> root     R     262m   7%   <span style=color:#ae81ff>0</span>  48% <span style=color:#f92672>{</span>stress-ng-vm<span style=color:#f92672>}</span> /usr/bin/stress-ng
    <span style=color:#ae81ff>6</span>     <span style=color:#ae81ff>1</span> root     R     <span style=color:#ae81ff>6900</span>   0%   <span style=color:#ae81ff>1</span>  48% <span style=color:#f92672>{</span>stress-ng-cpu<span style=color:#f92672>}</span> /usr/bin/stress-ng
    <span style=color:#ae81ff>1</span>     <span style=color:#ae81ff>0</span> root     S     <span style=color:#ae81ff>6256</span>   0%   <span style=color:#ae81ff>0</span>   0% /usr/bin/stress-ng -c <span style=color:#ae81ff>1</span> -m <span style=color:#ae81ff>1</span> --met
    <span style=color:#ae81ff>7</span>     <span style=color:#ae81ff>1</span> root     S     <span style=color:#ae81ff>6256</span>   0%   <span style=color:#ae81ff>0</span>   0% <span style=color:#f92672>{</span>stress-ng-vm<span style=color:#f92672>}</span> /usr/bin/stress-ng
    <span style=color:#ae81ff>9</span>     <span style=color:#ae81ff>0</span> root     R     <span style=color:#ae81ff>1516</span>   0%   <span style=color:#ae81ff>0</span>   0% top
</code></pre></div><p>測試用的行程 <code>CPU</code> 占用率為 <code>48%</code>，<code>stress-ng-vm</code> 的記憶體占 <code>262m(VSZ)</code>，其兩項資源都超出請求量，<code>stress-ng</code> 會在可用的範圍內盡量的占用相關的資源。內存為不可壓縮資源，因此 <code>POD</code> 在記憶體資源過載時可能會因 <code>OOM</code> 而被終止，而 <code>CPU</code> 則是會將多占用資源壓縮。因此，在 <code>K8s</code> 上運行關鍵應用程式相關的 <code>POD</code> 時需使用<code>requests</code> 定義最小可用資源。</p><ul><li><a href=https://manpages.ubuntu.com/manpages/artful/man1/stress-ng.1.html>stress-ng 介紹</a></li></ul><h5 id=limits>limits</h5><p><code>limits</code> 定義容器資源最大可用。定義此屬性可避免應用程式出現 Bug 導致資源長期被占用。下面的記憶體資源只要超出 <code>limits</code> 定義資源將被 <code>OOM</code> 終止。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>memleak-pod</span>
  <span style=color:#f92672>labels</span>:
    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>mem</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>containers</span>:
  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>simmemleak</span>
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>saadali/simmemleak</span>
    <span style=color:#f92672>resources</span>:
      <span style=color:#f92672>requests</span>:
        <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;64Mi&#34;</span>
        <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;1&#34;</span>
      <span style=color:#f92672>limits</span>:
        <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;64Mi&#34;</span>
        <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;1&#34;</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ kubectl get pod -o wide -w -l app<span style=color:#f92672>=</span>mem
NAME          READY   STATUS      RESTARTS   AGE   IP          NODE                                       NOMINATED NODE   READINESS GATES
memleak-pod   0/1     OOMKilled   <span style=color:#ae81ff>1</span>          22s   10.4.2.11   gke-cluster-1-default-pool-7dc8b11b-r7rg   &lt;none&gt;           &lt;none&gt;
memleak-pod   0/1     CrashLoopBackOff   <span style=color:#ae81ff>1</span>          25s   10.4.2.11   gke-cluster-1-default-pool-7dc8b11b-r7rg   &lt;none&gt;           &lt;none&gt;
memleak-pod   1/1     Running            <span style=color:#ae81ff>2</span>          28s   10.4.2.11   gke-cluster-1-default-pool-7dc8b11b-r7rg   &lt;none&gt;           &lt;none&gt;
memleak-pod   0/1     OOMKilled          <span style=color:#ae81ff>2</span>          29s   10.4.2.11   gke-cluster-1-default-pool-7dc8b11b-r7rg   &lt;none&gt;           &lt;none&gt;
</code></pre></div><p>與 <code>requests</code> 不同的是，<code>limits</code> 不會影響 <code>POD</code> 的調度結果，因此 <code>limits</code> 資源定義可大於節點所擁有的資源，當然過載使用還是會有容器會被 <code>OOM</code> 終止。</p><h2 id=pod-的-qos>POD 的 QoS</h2><p>當我們設置上一章節所說的屬性，在資源吃緊的情況下，應該要用什麼方式進行先後順序的終止 <code>POD</code> ? <code>K8s</code> 無法自己做出決策，需借助 <code>POD</code> 的優先級別。依照 <code>requests</code> 和 <code>limits</code> 屬性，<code>K8s</code> 將 <code>POD</code> 歸類到三種 <code>QoS</code> 類別下</p><ul><li>Guaranteed<ul><li>每個容器都為 <code>CPU</code> 資源設置了具有相同值的 <code>requests</code> 和 <code>limites</code> 屬性，以及每個容器都為記憶體資源設置了具有相同值的 <code>requests</code> 和 <code>limits</code> 屬性的 <code>POD</code> 資源會自動歸屬此類，而這類的 <code>POD</code> 資源具有最高優先權</li></ul></li><li>Burstable<ul><li>至少有一個容器設置了 <code>CPU</code> 或記憶體的 <code>requests</code> 屬性，但不滿足 <code>Guaranteed</code> 類別要求的 <code>POD</code> 資源自動歸屬此類，具有中等優先級別</li></ul></li><li>BestEffort<ul><li>沒有為任何容器設置 <code>requests</code> 或 <code>limits</code> 屬性的 <code>POD</code> 資源自對歸屬此類，優先級別最低</li></ul></li></ul><p>每個運行的容器都有 <code>OOM</code> 得分，得分越高越會被優先終止。<code>OOM</code> 得分主要根據兩個維度進行計算，由 <code>QoS</code> 類別繼承而來的默認值和容器的可用記憶體資源比例。同等類別的 <code>POD</code> 資源的默認值相同，下面的程式碼從 <code>pkg/kubelet/qos/policy.go</code> 取得，它們定義的是各種類別的 <code>POD</code> 資源 <code>OOM</code> 調節（Adjust）值，即默認值。</p><p>在同一等級的優先級別下的 <code>POD</code> 資源在 <code>OOM</code> 時，與自己的 <code>requests</code> 相比，其記憶體占用比例最大的 <code>POD</code> 將被先終止。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>const</span> (
    <span style=color:#a6e22e>PodInfraOOMAdj</span> <span style=color:#66d9ef>int</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>998</span>
    <span style=color:#a6e22e>KubeletOOMScoreAdj</span> <span style=color:#66d9ef>int</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>999</span>
    <span style=color:#a6e22e>DockerOOMScoreAdj</span> <span style=color:#66d9ef>int</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>999</span>
    <span style=color:#a6e22e>KubeProxyOOMScoreAdj</span> <span style=color:#66d9ef>int</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>999</span>
    <span style=color:#a6e22e>guaranteedOOMScoreAdj</span> <span style=color:#66d9ef>int</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>998</span>
    <span style=color:#a6e22e>besteffortOOMScoreAdj</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>1000</span>
)

</code></pre></div><h2 id=參考資源>參考資源</h2><ul><li><a href=https://k8smeetup.github.io/docs/tasks/administer-cluster/quota-memory-cpu-namespace/>針對 namespace 限制資源</a></li><li><a href=https://kubernetes.io/zh/docs/concepts/policy/limit-range/>有關限制資源的相關資料</a></li><li><a href=https://kubernetes.io/zh/docs/concepts/policy/resource-quotas/>資源額度</a></li></ul></div><div class="d-flex flex-row justify-content-around"><h3 class="mb-1 mt-1 text-left mr-4"><a href=/kubernetes/2020-08-31-pod-lifecycle/ title="kubernetes - day10"><i class="nav-menu fas fa-chevron-circle-left"></i></a></h3><h3 class="mb-1 mt-1 text-left ml-4"><a href=/kubernetes/2020-09-02-pod-controller/ title="kubernetes - day12"><i class="nav-menu fas fa-chevron-circle-right"></i></a></h3></div></main><footer class="mt-2 mb-4 text-center"><span class=markdownify>short copyright message</span>
<span>&#183;
<i><a href=https://github.com/darshanbaral/aafu>aafu</a></i>
by
<a href=https://www.darshanbaral.com/>darshan</a></span></footer></body></html>