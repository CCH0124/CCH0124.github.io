<!doctype html><html lang=en-us style=max-width:1000px;margin:auto><head><title>Kevin Blog</title><meta name=theme-color content><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta name=description content="Kevin learning"><meta name=author content="Kevin Chen"><meta name=generator content="aafu theme by Darshan in Hugo 0.83.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.15.2/css/all.css integrity=sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu crossorigin=anonymous><link rel=stylesheet href=https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css><link rel=stylesheet href="//fonts.googleapis.com/css?family=Didact+Gothic%7CRoboto:400%7CRoboto+Mono"><link rel=stylesheet href=/css/aafu_pinkish.css><link rel=stylesheet href=/css/aafu.css><script>var themeColor=document.querySelector("meta[name=theme-color]");window.onload=()=>{themeColor.content=getComputedStyle(document.body)["background-color"];let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")},window.onresize=()=>{let a=document.querySelector(".accordion.active");a&&(a.nextElementSibling.style.maxHeight=a.nextElementSibling.scrollHeight+"px")}</script></head><body class=container><main style="min-height:calc(100vh - 60px)"><div class="d-flex flex-row row p-2"><h3 class="main-menu mr-3"><a href=https://cch0124.github.io/>Home</a></h3><h3 class="main-menu mr-3"><a href=/blog>Blog</a></h3><h3 class="main-menu mr-3"><a href=/project>Project</a></h3><h3 class="main-menu mr-3"><a href=/life>Life</a></h3><h3 class="main-menu mr-3"><a href=/kubernetes>Kubernetes</a></h3><h3 class="main-menu mr-3"><a href=/code>Coding</a></h3></div><div class=mb-3><h1 class=top-h1 style=font-size:2.75em>kubernetes - day06</h1><p class=mb-1>August 27, 2020</p><p>&mdash;</p></div><div class=content><h2 id=資源配置清單>資源配置清單</h2><p><code>Kubernetes</code> 中資源基本上都是需要五個字段定義資源，分別是 <code>apiVersion</code>、<code>kind</code>、<code>metadata</code>、<code>spec</code> 和 <code>status</code>。以下分別介紹</p><ul><li><code>apiVersion</code><ul><li>group/version</li><li>定義 api-versions</li></ul></li><li><code>kind</code><ul><li>資源類型</li></ul></li><li><code>metadata</code><ul><li>用來定義一些訊息，如名稱、所屬 <code>namespace</code> 與標籤等</li></ul></li><li><code>spec</code><ul><li>定義所期望的狀態</li></ul></li><li><code>status</code><ul><li>紀錄當前對象狀態</li><li>由 Kubernetes 維護，因此客戶端不需要去定義</li></ul></li></ul><p>這邊使用 <code>get</code> 方式取得 <code>kube-system</code> 的預設 <code>namespcae</code> 資訊，並以 <code>yaml</code> 輸出。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ kubectl get namespace kube-system -o yaml
apiVersion: v1
kind: Namespace
metadata:
  creationTimestamp: <span style=color:#e6db74>&#34;2020-08-22T02:00:45Z&#34;</span>
  name: kube-system
  resourceVersion: <span style=color:#e6db74>&#34;4&#34;</span>
  selfLink: /api/v1/namespaces/kube-system
  uid: 73058111-fb1f-48a6-b283-338207167625
spec:
  finalizers:
  - kubernetes
status:
  phase: Active
</code></pre></div><p>大致上相關資源都是以上面格式進行清單定義創建資源。以下練習建立一個 <code>namespace</code> 資源。為何不用定義跟上述一樣的字段 ? 在 <code>Kubernetes</code> 中，有些字段必須要填寫，有些則不用，而不用的 <code>Kubernetes</code> 會自動將期補齊。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Namespace</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ kubectl creat -f namespace-example.yaml
$ kubectl get namespace <span style=color:#75715e># 這邊會看到所建立的 test namespace 資源</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#75715e># 自動補齊一些字段值</span>
$ kubectl get namespace test -o yaml
apiVersion: v1
kind: Namespace
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;apiVersion&#34;</span>:<span style=color:#e6db74>&#34;v1&#34;</span>,<span style=color:#e6db74>&#34;kind&#34;</span>:<span style=color:#e6db74>&#34;Namespace&#34;</span>,<span style=color:#e6db74>&#34;metadata&#34;</span>:<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;annotations&#34;</span>:<span style=color:#f92672>{}</span>,<span style=color:#e6db74>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;test&#34;</span><span style=color:#f92672>}}</span>
  creationTimestamp: <span style=color:#e6db74>&#34;2020-08-22T04:24:30Z&#34;</span>
  name: test
  resourceVersion: <span style=color:#e6db74>&#34;370645&#34;</span>
  selfLink: /api/v1/namespaces/test
  uid: bcfe414a-cab9-400c-b004-38672c0bc065
spec:
  finalizers:
  - kubernetes
status:
  phase: Active
</code></pre></div><p>雖然上面建立了 <code>namespace</code> 資源，但那些字段我們可以去使用 ? 在 <code>Kubernetes</code> 中有文檔可以翻閱查看，也可以使用 <code>kubectl explain</code> 的方式去查找，相同的會給一些相關資源必須的字段，和描述當中還附著官方文檔的鏈接，相當的好用。</p><h3 id=總結>總結</h3><p>資源清單方式是建立資源的一種方式，當然也可以用指令去建立，下一個段落會說明如何去管理這些資源。但是資源清單有許多優勢，像是可配置屬性較多因此可以有較高層級的操作、可用於 <code>git</code> 版控追蹤等。</p><h2 id=資源對象管理方式>資源對象管理方式</h2><p>在 <code>kubectl</code> 中有三種方式管理資源</p><ul><li>Imperative commands</li><li>Imperative object configurations</li><li>Declarative object configurations</li></ul><h3 id=imperative-commands>Imperative commands</h3><ul><li>透過指令方式管理資源</li><li>通常於開發或測試使用</li></ul><pre><code class="language-shell=" data-lang="shell=">$ kubectl run/create/delete/label/scal/patch/edit ...
</code></pre><p>但在真實部署中會把上述的動作描寫成一個檔案，紀錄這些動作。然而這些指令很檢簡易的使用，缺點是可能透過這些指令寫成 <code>Shell</code> 而不好維護。當中 <code>edit</code> 指令可用於修改 <code>POD</code> 運行資源的檔案需求內容，但 <code>edit</code> 在實際部署時不適合，因為無法記錄修改了什麼。</p><h3 id=imperative-object>Imperative object</h3><p>透過物件方式去描述增減刪資源等。會透過 <code>yaml</code> 或 <code>json</code> 管理資源。</p><p>建立</p><pre><code class="language-shell=" data-lang="shell=">$ kubectl create -f FILE.yaml
</code></pre><p>刪除</p><pre><code class="language-shell=" data-lang="shell=">$ kubectl delete -f FILE.yaml
</code></pre><p><code>replace</code>，根據修改的檔案內容進行替換。但，自定義的 <code>yaml</code> 跟系統上面的 <code>yaml</code> 不一樣，因此無法覆蓋。少資源覆蓋多資源是不可行，應該是要一模一樣才對，透過 <code>-o yaml</code> 可以取得完整 <code>yaml</code>。在進行 <code>replace</code> 時，無定義的 <code>yaml</code> 都會被檢視出來，因此要先取得完整 <code>yaml</code> 在進行 <code>replace</code>。</p><pre><code class="language-shell=" data-lang="shell=">$ kubectl replace -f FILE.yaml
</code></pre><p>而利用這些資源管理，對於更新是要取得最新資源的檔案。並透過上述提到的指令進行相對應操作。</p><ul><li><a href=https://kubernetes.io/docs/tasks/manage-kubernetes-objects/imperative-command/>imperative-command</a></li></ul><h3 id=declarative-object>Declarative object</h3><p>同樣也是使用檔案描述，底層由 <code>kubernetes</code> 維護，也就是其他未定義欄位。因此會針對先前修改過的欄位比較，並進行刪或更新動作。相較於 <code>create</code> 是去創建，而 <code>apply</code> 則是維護。</p><pre><code class="language-shell=" data-lang="shell=">$ kubectl apply -f file # 可以遞規當前目錄下所有檔案和目錄
$ kubectl diff ... # 比較差異
</code></pre><h3 id=總結-1>總結</h3><p><img src=http://assets.digitalocean.com/articles/comics/imperative-declarative-k8s.jpg alt>
上圖為 digitalocean 提供。</p><p>透過 <code>create</code> 再 <code>replace</code> 操作，叫做<em>命令式配置</em>(Imperative object configurations)操作。告訴機器先做什麼，再做什麼，機器按照一條一條的命令規則去實作。</p><p>透過 <code>apply</code> 進行<em>創建</em>和<em>滾動</em>更新，叫做<em>聲明式 API</em>操作。告訴機器去做什麼，但不細說具體指令(<code>kubernetes</code> 會維護)，它會自動識別完成任務。</p><p><code>replace</code> 的執行過程，是使用新的 <code>YAML</code> 文件中的 <code>API</code> 對象，替換原有的 <code>API</code> 對象。<code>API Server</code> 在響應命令式請求(Imperative commands)時，一次只能處理一個寫請求，否則就會產生衝突的可能，一條一條按順序執行響應。</p><p><code>apply</code> 是執行了一個對原有 <code>API</code> 對象的 <code>Patch</code> 操作。類似還要 <code>set image</code> 和 <code>edit</code>。 <code>API Server</code> 在響應聲明式請求(Declarative object configurations)時，一次能處理多個寫操作，並且具備整合的能力。</p><h2 id=參考資源>參考資源</h2><ul><li><a href=https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/>官方 物件管理</a></li><li><a href=https://containers.goffinet.org/k8s/declarative.html>Declarative vs imperative in Kubernetes</a></li></ul></div><div class="d-flex flex-row justify-content-around"><h3 class="mb-1 mt-1 text-left mr-4"><a href=/kubernetes/2020-08-26-pod-controller-resource/ title="kubernetes - day05"><i class="nav-menu fas fa-chevron-circle-left"></i></a></h3><h3 class="mb-1 mt-1 text-left ml-4"><a href=/kubernetes/2020-08-28-namespace-pod-resource-operation/ title="kubernetes - day07"><i class="nav-menu fas fa-chevron-circle-right"></i></a></h3></div></main><footer class="mt-2 mb-4 text-center"><span class=markdownify>short copyright message</span>
<span>&#183;
<i><a href=https://github.com/darshanbaral/aafu>aafu</a></i>
by
<a href=https://www.darshanbaral.com/>darshan</a></span></footer></body></html>