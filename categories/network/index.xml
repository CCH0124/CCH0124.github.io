<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Network on</title><link>https://cch0124.github.io/categories/network/</link><description>Recent content in Network on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 16 Jan 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://cch0124.github.io/categories/network/index.xml" rel="self" type="application/rss+xml"/><item><title>ping 指令</title><link>https://cch0124.github.io/blog/2017-01-16-ping/</link><pubDate>Mon, 16 Jan 2017 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2017-01-16-ping/</guid><description>ping 是網路上常見的診斷工具。
用來判斷網路是否可連線 是否有設備連接 ping 是網路中必要的工具。
以下會介紹 ping 的使用以及 ICMP 協定。
ping work 發送 ICMP(Internet Control Message Protocol) 封包至目的端，最後的訊息可以判斷網路狀態的優良。 ICMP 主要用於確定數據是否及時到達預定目的地。當兩個設備透過 Internet 連線時，如果任何數據未到達其預期目的地，則 ICMP 會生成錯誤回傳。常用的終端應用程式 traceroute 和 ping 都使用 ICMP 進行操作。
ping [options] [destination] ping options
-c 指定要發送的 packet 數量 -s 更改 packet 的大小 -v 詳細訊息 -w 指定命令執行結束的時間（以秒為單位）無論命令發送或接收的 packet 數量 -i 可以指定要使用的網路介面 ping destination</description></item><item><title>ARP Protocol</title><link>https://cch0124.github.io/blog/2016-10-02-arp/</link><pubDate>Thu, 12 May 2016 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2016-10-02-arp/</guid><description>ARP 從本地端電腦傳送封包到你瀏覽的網頁，他會利用 IP Address 把封包傳送至目的地。但，這之間會學習到目的地 Host 的 MAC Address（Media Access Control Address），這樣才能達到準確溝通。在 Ethernet（乙太網路）環境下，Ethernet進行了連線、傳遞訊號等。要用 IP Address 找出 MAC 得要用 ARP（Address Resolution Protocol） ，ARP 屬於 OSI Model 網路層。
ARP 學習 當 R1 想找 PC1，但 R1 什麼都不知道，只認識自己。R1 發送 broadcast 發出一個 ARP Request，ARP Request 包含了PC1 的 IP Address 等，到了 Switch1 進行 flooding 使每個目的端 Host 都接收（因為是 broadcast）。接著，目的端都接收，會進行 ARP reply 的動作，只有符合 R1 要找的 IP 才會進行回覆以 unicast 方式，其餘的 Host 會把此 frame Drop 掉，之後 R1 會把找到的 Host MAC 給記錄到 ARP 表格。</description></item><item><title>IP Routing</title><link>https://cch0124.github.io/blog/2016-04-12-ip-routing/</link><pubDate>Tue, 12 Apr 2016 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2016-04-12-ip-routing/</guid><description>IP Routing 簡易來說就是我們從台灣主機到美國 google 主機，所經過的路徑過程。過程之間都是透過路由器的決策來完成。路由器會得知目的地 IP，藉由路由表決定下一跳的路徑，接著轉發封包。
假設 TW 想要取得 Google 的資訊，但是 Google 在跟 TW 不同的網路上。TW 會發送封包至路由器，路由起接收到封包後，會得知目的地 IP 位址，並對照路由表做決策再將 TW 發送至路由器的封包轉發到跟目標網路關聯的介面，最後抵達 Google。
Gateway 本地端主機要和遠方的主機通訊。當主機沒有遠方的主機路由資訊時，會發送至 Gateway。該 Gateway 的路由器會再做決策。
如上面的圖
TW 設置有路由器其中一個介面的 IP，TW 嘗試與遠方不同網路的 google 通訊。TW 在路由表中查找目標網路是否有路徑可到達。如果未找到該路徑，則 TW 將封包發送至路由器上的 TW Gateway IP。路由器接收風包後並將封包轉發給 google。
Routing Table 路由器會維護一個路由表並儲存在 RAM 中。路由器使用路由表來確定到目標網路的路徑。 每個路由表包含以下資訊：
R1#show ip route Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2 E1 - OSPF external type 1, E2 - OSPF external type 2 i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2 ia - IS-IS inter area, * - candidate default, U - per-user static route o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP + - replicated route, % - next hop override Gateway of last resort is not set 192.</description></item><item><title>子網路切割</title><link>https://cch0124.github.io/blog/2016-03-30-subnetting/</link><pubDate>Wed, 30 Mar 2016 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2016-03-30-subnetting/</guid><description>子網路 子網路劃分將網路切成多個小規模的網路，以提高路由效率、增強網路管理的安全也減小了廣播的功能。
如下示意圖
假設在一層大樓中，有分軟體部門、硬體部門、UI/UX 部門，將所有主機都分配至 192.168.0.0/24 子網路中。缺點會有以下：
廣播域問題 所有主機都在同一個廣播域中。所有主機都將處理網路上任何設備發送的廣播。應該要讓硬體部門的網路流量不影響其它部門，這樣可以提升效能。 網路上的安全 每個設備都可以訪問子網上的任何其他設備，這可能會帶來安全問題。例如，軟體部門有敏感訊息的服務將與其它的部門工作站位於同一網路中。 組織問題 部門盡量不要在同一子網路中 規劃之後
在規劃之後每個部門分配在不同子網中也位於不同的廣播域。</description></item><item><title>交換器基本介紹</title><link>https://cch0124.github.io/blog/2016-03-28-switch/</link><pubDate>Mon, 28 Mar 2016 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2016-03-28-switch/</guid><description>Switch 在網路設備中負責轉發網路封包。但，轉發這動作之前，Switch 也必須知道封包轉發的目的地以及要從哪一個埠轉發出去。
Switch 主要功能 能夠增加網路的可用頻寬 製作出 MAC table 分析其中的來源端與目的端的 MAC 位址 藉由 MAC table 正確的轉發網路封包 擁有較高速的內部結構 擁有比較多的埠介面 跟傳統的閘道器（Bridge）比較起來，交換器能夠提供更多的網路流量 MAC 位址學習 Switch 會從它們的埠上監聽所傳進來的 Frame（經過交換器的網路封包稱之為 Frame），檢測這些資料的來源端 MAC 位址，並且把 MAC 位址與埠號的對應關係記錄下來，儲存在本地端的 MAC Address Table 或是 Content-addressable Memory (CAM) Table。 當 Switch 再次收到 Frame，會先至 MAC Address Table 中察看哪個埠可以轉發至目的地 MAC 位址，如果有在 MAC Address Table，則這 Frame 會從學習到的埠轉發出去，否則這 Frame 會從除了來源埠之外的埠轉發出去。
當 Switch 收到 Frame 之後，一定會從所有其他的埠轉發出去，除了來源埠之外。這種轉發到除來源埠以外的其他埠的動作，稱為「Flooding」。用這種 Flooding 的動作來轉送Frame 很沒有效率，因為會浪費很多網路頻寬。
Switch 傳送 Frame 的模式 Store and Forward 交換器會先把 Frame 完整地接收下來，然後才進行轉發的動作 來源端及目的端的 MAC 位址都能夠被讀取 CRC（Cyclic Redundancy Check）錯誤檢查動作會被執行 檢查失敗，Frame 會被遺棄 確保 Frame 中資料的正確性 較費時 延遲時間與 Frame 的資料長度有關 Cut-Though 雖然有些交換器在這種模式下只想讀取 MAC 位址，但還是有某些交換器會讀取 CRC 值並記錄下錯誤數目。</description></item><item><title>路由器基本介紹</title><link>https://cch0124.github.io/blog/2016-03-22-router/</link><pubDate>Tue, 22 Mar 2016 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/blog/2016-03-22-router/</guid><description>Router 介紹 Routing 是決定網路封包要如何送往外部網路到達目的地的過程 Router 會取得達到路由所必須的資訊，並加以維護，而為了取得並維護這樣的路由資訊，必須使用路由協定 最主要的工作是決定要將網路封包送往何處 為了要讓封包送往目的地，必須學習以下
知道目的端的位址在哪裡 標示出來源端的位址，並把它學習起來 尋找這個封包可能要送往的路徑有哪些 從可能的路徑中選出最佳路徑 維護並更新這些路由所需的資料 Switch 也可以把封包轉發到目的地，它與 Router 運作方式不同。
路由器轉發封包決定方式 根據 Routing Table 的資料來決定如何轉發資料封包
Static Route 手動輸入 速度快 不須要經過學習 網路拓樸若有任何的改變，管理人員必須更新這些資料到路由器設備中 比較適合幾乎不會有變動的網路拓樸 Dynamic Route 不須要手動輸入 路由器設備之間去協調 互相交換並學習這些資料 只要做 Routing Protocol 的設定 較耗費系統資源，速度也稍微慢 系統需要時間去做學習的動作 需要一點時間才能把 Routing Table 建立得比較完整\ 網路架構有任何的改變，路由設備會自我學習維護 Routing Table Administrative Distance 來決定每一種不同路由協定的可靠程度 AD 值是一個從 0～255 的整數，每一種路由協定都有一個 AD 值與之對應 其值越低，代表可靠程度越高 路由方式對應 AD 值 路由方式 AD 預設值 直連 0 靜態路由 1 EIGRP Summary Route 5 外部 BGP 20 EIGRP 90 IGRP 100 OSPF 110 RIPv1、RIPv2 120 EGP(Exterior Gateway Protocol) 140 External EIGRP 170 Internal BGP 200 DHCP-learned 254 未知 255 Autonomous System 自治系統（Autonomous System）簡稱 AS，所有處於同樣管理網域（Administrative Domain）下所有網路的集合</description></item></channel></rss>