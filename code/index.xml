<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Coding on</title><link>https://cch0124.github.io/code/</link><description>Recent content in Coding on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 02 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cch0124.github.io/code/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring security - CSRF(Cross-site request request forgery)</title><link>https://cch0124.github.io/code/2021-11-02-csrf/</link><pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-11-02-csrf/</guid><description>CSRF 原理網路上有很多解釋這邊不再進一步介紹，推薦cloudflare 所寫的內容。
在 Spring Security CSRF 會針對 PATCH、POST、PUT 和 DELETE HTTP 方法進行防護。在先前的範例中我們將 CSRF 關閉
.and().csrf().disable(); 只要將其拿掉即可開啟 CSRF 防護。
Spring Security CSRF 原理 從 CsrfFilter 類別中查看 doFilterInternal 方法，可以大致清楚知道它的處裡邏輯。
@Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { request.setAttribute(HttpServletResponse.class.getName(), response); CsrfToken csrfToken = this.tokenRepository.loadToken(request); boolean missingToken = (csrfToken == null); if (missingToken) { csrfToken = this.tokenRepository.generateToken(request); this.tokenRepository.saveToken(csrfToken, request, response); } request.setAttribute(CsrfToken.class.getName(), csrfToken); request.setAttribute(csrfToken.getParameterName(), csrfToken); if (!this.requireCsrfProtectionMatcher.matches(request)) { if (this.</description></item><item><title>Spring security - user logout 與自動登入</title><link>https://cch0124.github.io/code/2021-10-30-spring-security-user-logout/</link><pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-30-spring-security-user-logout/</guid><description>logout 以下是一個使用者登出後的配置，登出成功後頁面會跳轉到 /api/v1/index
@Override protected void configure(HttpSecurity http) throws Exception { // TODO Auto-generated method stub // logout http.logout().logoutUrl(&amp;#34;/logout&amp;#34;).logoutSuccessUrl(&amp;#34;/api/v1/index&amp;#34;).permitAll(); http.exceptionHandling().accessDeniedPage(&amp;#34;/403.html&amp;#34;); http.formLogin() // 自定義編寫登入頁面 ... } 撰寫一個登出頁面如下，同時也修改上面的 defaultSuccessUrl 配置將其換成 defaultSuccessUrl(&amp;quot;/success.html&amp;quot;)
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Success&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Success&amp;lt;/h1&amp;gt; &amp;lt;br&amp;gt; &amp;lt;a href=&amp;#34;/logout&amp;#34;&amp;gt;&amp;lt;b&amp;gt;logout&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 實驗過程可以請求 http://localhost:8080/login.html 會跳轉到 http://localhost:8080/success.html 此時可以進行頁面的 API 請求。
自動登入 要實現的話會將數據儲存自 cookie 與 database，並進行比對。整體架構如下
________________ _____________________________ | | _____________________________________ | | | | 1 | | 2 | | | |-----------&amp;gt;| UsernamePassworAuthenticationFilter|-----------&amp;gt;| | | | |____________________________________| | | | | | ___________________ | ________ | | | | RemeberMeService| | | | | browser | | |_________________| | 4 | | | | 3 | ___________________ | --------------&amp;gt; | DB | | |&amp;lt;-------------------------------------------------------------| | TokenRepository| | 13 | | | | | |_________________| | --------------&amp;gt; |________| | | | | | | _____________________________________ | | | | 11 | | | | ______________________ | | | | 12 | | 14 | | | |-----------&amp;gt;| RememberMeAuthenticationFilter |-----------&amp;gt;| | --------------&amp;gt;| UserDetailsService | |________________| |____________________________________| |____________________________| |_____________________| 初始請求</description></item><item><title>Spring security - annotation</title><link>https://cch0124.github.io/code/2021-10-29-spring-security-annotation/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-29-spring-security-annotation/</guid><description>註解是為了可以方便讓我們使用，以下將會介紹註解。實驗過程可藉由更改 commaSeparatedStringToAuthorityList 方法所傳遞的權限進行調整
List&amp;lt;GrantedAuthority&amp;gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&amp;#34;admins,ROLE_sale&amp;#34;); @Secured 判斷是否具有角色，有的話表示可以存取該方法，這邊匹配的角色需加上 **ROLE_**。在使用註解時須先開啟註解功能 @EnableGlobalMethodSecurity
@SpringBootApplication @EnableGlobalMethodSecurity(securedEnabled = true) public class Securitydemo01Application { public static void main(String[] args) { SpringApplication.run(Securitydemo01Application.class, args); } } 透過 @Secured 註解可讓該方法被限制只能是 &amp;ldquo;ROLE_sale&amp;rdquo; 或 &amp;ldquo;ROLE_manager&amp;rdquo; 才能存取。
@GetMapping(&amp;#34;/update&amp;#34;) @Secured(value = {&amp;#34;ROLE_sale&amp;#34;,&amp;#34;ROLE_manager&amp;#34;}) public String update() { return &amp;#34;Hello update&amp;#34;; } @PreAuthorize 進入該方法前的權限驗證，可將登入使用者的 roles/permissions 參數傳到方法中。同樣的要使用該註解必須啟用，在 @EnableGlobalMethodSecurity 添加 prePostEnable=true。
@GetMapping(&amp;#34;/preAuth&amp;#34;) @PreAuthorize(value = &amp;#34;hasAnyAuthority(&amp;#39;admins&amp;#39;)&amp;#34;) public String preAuth() { return &amp;#34;Hello preAuth&amp;#34;; } 其中 hasAnyAuthority 也可以是 hasAuthority、hasRole 或 hasAnyRole 等，以下整理了一張表</description></item><item><title>Spring security 概觀</title><link>https://cch0124.github.io/code/2021-10-28-spring-security-overview/</link><pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-28-spring-security-overview/</guid><description>在 Spring Security 主要核心功能是 Authentication(使用者認證) 和 Authorization(使用者授權)兩部份。
Authentication 使用者是否能訪問該系統，一般都是透過帳號和密碼進行確認。 Authorization 用戶是否有權限執行某個操作，也就是系統上會有很多角色分配給使用者，而這些使用者能操作的動作就對應到角色。 演示 pom.xml ... &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; ... 撰寫一個 controller @RestController @RequestMapping(&amp;#34;/api/v1&amp;#34;) public class TestController { @GetMapping(&amp;#34;/hello&amp;#34;) public String hello() { return &amp;#34;Hello Security&amp;#34;; } } 對設計的 controller 進行請求 會發現會被導到一個登入頁面，這也可以表示 Spring Security 有被啟用。 預設的使用者是 user 密碼則會是在 console 中以 Using generated security password: d7ce1ace-a637-4896-8556-a531dedbab29 呈現。登入後即可呈現我們所請求的內容。
基本原理 Spring Security 和 iptable 一樣都是一串鏈連接起來的。下面會介紹較為重要的過濾器</description></item><item><title>Spring boot Web 開發 - Error Handler</title><link>https://cch0124.github.io/code/2021-10-27-error-handler-spring-boot/</link><pubDate>Wed, 27 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-27-error-handler-spring-boot/</guid><description>從官方介紹內容來看錯誤處理內從大概是以下
默認規則 預設下，Spring boot 提供 /error 處理所有錯誤的映射 對於非瀏覽器類型，會以 JSON 進行回應，其中包含錯誤、HTTP 狀態和異常訊息；對於瀏覽器則會以 whilelabel 進行視圖回應，會以 HTML 方式呈現 要自定義，添加 View 解析為 Error 要完全替代預設的行為，可以實作 ErrorController 並註冊該類型的 Bean 定義，或添加 ErrorAttributes 類型的組件以替換內容 異常整體流程處理
執行目標方法，只要期間有錯誤都會被 JAVA 的 catch 語法給抓到，並將當前請求結束，其過程會進入 dispatchException 進入 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException) 當中 mv = processHandlerException，處理 handler 發生的異常，接著回傳 ModelAndView，過程會遍歷 handlerExceptionResolvers，看誰能處理，系統默認的解析起有以下 DefaultErrorAttributes 先來處理異常。把異常訊息給 request，並返回 null HandlerExceptionResolveComposite ExceptionHandlerExceptionResolver ResponseStatusExceptionResolver DefaultHandlerExceptionResolver 預設下沒有東西可以處理異常，因此異常被拋出，最後發送 /error 請求，被底層 BasicErrorController 處理。 定制錯誤邏輯 自定義錯誤頁面 在 error 目錄下進行匹配 @ControllerAdvice+@ExceptionHandler 底層是 ExceptionHandlerExceptionResolver @ResponseStatus+自定義異常 底層是 ResponseStatusExceptionResolver，把 @ResponseStatus 註解訊息底層調用 response.</description></item><item><title>lombok 利器</title><link>https://cch0124.github.io/code/2021-10-17-lombok/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-17-lombok/</guid><description>maven 引用 Lombok 方式
&amp;lt;dependencies&amp;gt; ... &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.18.20&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; ... &amp;lt;/dependencies&amp;gt; 在 Spring boot 中預設也將 lombok 作為套件，從下面範例來看我們透過 @Data 自動生成 get、set 方法；@ToString 產生 toString() 方法；透過 @AllArgsConstructor 產生有參數的建構方法，相反的使用 @NoArgsConstructor 則為無參數。使用 @EqualsAndHashCode 幫我們重寫 HashCode 和 equals。透過 @Slf4j 則會幫我們注入 Log 相關的操作。
@Data @ToString public class Car { private String brand; private Integer price; } 當要使用並構建一個物件時都需要
Product product = new Product(); product.setPrice(100); product.setName(&amp;#34;Apple&amp;#34;); 但藉由 @Builder 的註解，可以省下一些細節
Product product = Product.builder() .price(100) .name(&amp;#34;Apple&amp;#34;) .</description></item><item><title>Spring boot Web 開發</title><link>https://cch0124.github.io/code/2021-10-17-spring-boot-web/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-17-spring-boot-web/</guid><description>Spring boot provides auto-configuration for Spring MVC that works well with most applications.
請求參數處理 請求映射 RequestMapping value 請求路徑 method 使用的 HTTP Method @RequestMapping(value=&amp;#34;path&amp;#34;, method=RequestMethod.GET) public SomeData requestMethodName(@RequestParam String param) { return new SomeData(); } 在 Spring boot 中以下的請求映射都繼層於 RequestMapping
GetMapping PostMapping DeleteMapping PutMapping DispatcherServlet 是處理所有請求的開始，往上追最後會繼層一個 HttpServlet，當中請求會調用 doGet 方法（如果是 Get 請求），在 DispatcherServlet 中所有請求都會調用 doDispatch(HttpServletRequest request, HttpServletResponse response)。所有請求都存在於 HandlerMapping 中在 Spring boot 中有 5 種，Spring boot 自動配置歡迎頁面的 WelcomePageHandlerMapping，只要請求訪問 / 能訪問到 index.</description></item><item><title>Spring boot 概觀</title><link>https://cch0124.github.io/code/2021-10-17-spring-boot/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-10-17-spring-boot/</guid><description>Spring 能做什麼 Microservice Reactive Cloud Web apps Serverless FaaS Event Driven Batch Spring 生態圈很大。包含以下
Spring Framework DI AOP Spring Data 數據操作部分 Spring Cloud Spring Security Spring Session Spring boot 底層是 Spring Framework。Spring5 後有了變化，有了 spring reactive JAVA 8 的特性也改變底層的實現原理，像是預設的 interface。
什麼是 Spring boot Spring boot makes it easy to create stand-alone, production-grade Spring based Application that you can &amp;ldquo;just run&amp;rdquo;.</description></item><item><title>單元測試</title><link>https://cch0124.github.io/code/2021-09-06.junit5/</link><pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-09-06.junit5/</guid><description>Junit5 是目前最新的框架，其由三個模組組成
JUnit Platform 在 JVM 上啟動測試框架的基礎，在 Junit 之外的框架都能接入 JUnit Jupiter Junit5 的核心，內部包含了一個測試引擎，用於在 JUnit Platform 上運行 JUnit Vintage &amp;hellip; ___________________________________________________________________________________________________________________________________ | | | | | Junit5 | | ________________________ ________________________ ________________________ | | | | | | | | | | | | | | | | | | | JUnit Platform | + | JUnit Jupiter | + | JUnit Vintage | | | | | | | | | | | |_______________________| |_______________________| |_______________________| | | | | | | | | | |__________________________________________________________________________________________________________________________________| Srping boot 2.</description></item><item><title>LeetCode 268 Missing Number</title><link>https://cch0124.github.io/code/2021-01-12-missing-number/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-01-12-missing-number/</guid><description>Missing Number 題目 找出陣列中缺少的數值。思路利用數組長度帶入梯形公式算出3整個序列之和再減去目前數組中所有數值之和，即可獲取答案。
class Solution { public int missingNumber(int[] nums) { int len = nums.length; int trape = (0 + len)*(len+1)/2; int sum = Arrays.stream(nums).sum(); return trape - sum; } }</description></item><item><title>LeetCode Contains Duplicate I and II</title><link>https://cch0124.github.io/code/2021-01-02-contains-duplicate/</link><pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2021-01-02-contains-duplicate/</guid><description>Contains Duplicate 題目 217，檢查數組中是否有相同的值。思路一使用 Hash 方式，如果出現相同值 Hash 值會撞，如果撞表示是重複值。思路二使用 Set 不存放相同的值，最後比較 Set 存放的元素個數使否小於原始數組元素個數。
class Solution { public boolean containsDuplicate(int[] nums) { HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;nums.length; i++){ if (map.containsKey(nums[i])){ return true; } else { map.put(nums[i], 1); } } return false; } } class Solution { public boolean containsDuplicate(int[] nums) { Set&amp;lt;Integer&amp;gt; set = Arrays.stream(nums).boxed().collect(Collectors.toSet()); return set.size() &amp;lt; nums.length; } } Contains Duplicate II 題目 219，相較於第一版則是多了一個條件，把出現重複的值其所在的元素位置進行相減，並且要小於或等於給定的 k。這邊延伸第一版的程式碼，只是多了位置的判別。
class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i=0; i&amp;lt;nums.</description></item><item><title>LeetCode Best Time to Buy and Sell Stock I and II</title><link>https://cch0124.github.io/code/2020-12-31-best-time-to-buy-and-sell-stock/</link><pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-31-best-time-to-buy-and-sell-stock/</guid><description>Best Time to Buy and Sell Stock I 題目說明，如果只允許最多完成一筆交易，找到最大的利潤。也就是找到最大獲利的價差。
class Solution { public int maxProfit(int[] prices) { int min = Integer.MAX_VALUE; int max = 0; for (int i=0; i&amp;lt;prices.length; i++){ int price = prices[i]; if (price &amp;lt; min){ min = price; } else if (price - min &amp;gt; max) { max = price - min; } } return max; } } Best Time to Buy and Sell Stock II 題目說明，相較於第一版，這次是找出多筆交易中可獲利最大的價值。思路是，前後的價值為正數表示此交易有獲利，最後把這多筆的獲利相加。</description></item><item><title>LeetCode Pascal's Triangle I and II</title><link>https://cch0124.github.io/code/2020-12-26-pascals-triangle/</link><pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-26-pascals-triangle/</guid><description>Pascal&amp;rsquo;s Triangle 題目，思路就是動態規劃的概念。
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generate(int numRows) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); if (numRows == 0) return res; List&amp;lt;Integer&amp;gt; base = new ArrayList&amp;lt;&amp;gt;(); base.add(1); res.add(base); for (int i=1; i&amp;lt;numRows; i++){ List&amp;lt;Integer&amp;gt; row = new ArrayList&amp;lt;&amp;gt;(); row.add(1); for(int j=1; j &amp;lt; i; j++){ row.add(res.get(i-1).get(j) + res.get(i-1).get(j-1)); } row.add(1); res.add(row); } return res; } } Pascal&amp;rsquo;s Triangle II 題目相較於第一版本它是要取出某一列，概念上是相同。
class Solution { public List&amp;lt;Integer&amp;gt; getRow(int rowIndex) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; base = new ArrayList&amp;lt;&amp;gt;(); base.</description></item><item><title>LeetCode Two Sum I and II</title><link>https://cch0124.github.io/code/2020-12-25-two-sum/</link><pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-25-two-sum/</guid><description>Two Sum I 題目內容是說從給予的陣列中找出兩個索引值相加等於給定目標值。這邊使用 HashMap 的概念實現題目要求。
class Solution {s public int[] twoSum(int[] nums, int target) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int complement = target - nums[i]; if (map.containsKey(complement)) { return new int[] { map.get(complement), i }; } map.put(nums[i], i); } return new int []{}; } } Two Sum II 題目相較於第一版本對陣列進行排序。思路是使用兩個指針方式進行遍歷。
class Solution { public int[] twoSum(int[] numbers, int target) { int start = 0; int end = numbers.</description></item><item><title>物件導向 01 - extends</title><link>https://cch0124.github.io/code/2020-12-17-oop-extends/</link><pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-17-oop-extends/</guid><description>繼承(extends) 好處是減少代碼冗余、增加覆用性、便於功能的擴展、多態性。子類繼承父類後，子類會獲取父類的結構、屬性、方法，如果為 private，因為封裝性影響，子類不能直接調用父類結構，需透過 getter 和 setter 進行操作。
子類繼承之後可以聲名自己持有的屬性和方法，實現功能擴展。在 JAVA 只支持單繼承和多層繼承，無多重繼承。一個類能被多個子類繼承，一個類只能有一個父類。
所有 java 類（除 java.lang.Object）直接會間接繼承 java.lang.Object 類
覆寫 (override) 回傳類型、方法名和參數個數需一致 回傳類型可以是該類型的子類 同名同參數方法要是非 static 實現重寫，否則為非重寫 子類重寫的方法權限修飾不小於父類被重寫的方法的權限 子類拋出的異常範圍不能大於父類 以繼承來說 B 繼承 A，只要 B 有覆寫 A 的相關方法，則建立物件時取得的是 B 的覆寫，否則就是 A 的。
super 用來調用以下
屬性
法
建構方法
在子類的方法或建構方法中，透過使用 super.屬性或 super.方法的方式，顯示的調用父類中聲明的屬性或方法，通常都省略
當子類和父類中定義同名屬性時，要從子類調用父類的屬性，則必須使用 super.屬性或 super.方法
在建構方法中使用 super(參數列表)
需再首行</description></item><item><title>物件導向 01 - 類的成員</title><link>https://cch0124.github.io/code/2020-12-17-oop-class/</link><pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-17-oop-class/</guid><description>OOP 學習 JAVA 的 Class 與 Class 中的成員 屬性 方法 建構方法 區塊 內部類 以下特徵 封裝 繼承 多態 抽象 Class 與 Object Class 為對事物的描述，一種抽象概念。Object 實際存在的個體，也稱實例(instance)。
以下為 Class 範例，當中會包含屬性與行為
class Person { // 屬性 String name; int age; // 行為 public void eat() { System.out.println(&amp;#34;吃飯&amp;#34;); } public void sleep() { System.out.println(&amp;#34;睡覺&amp;#34;); } public void say(String language) { System.out.println(&amp;#34;我使用&amp;#34; + language + &amp;#34;說話&amp;#34;); } } 當把人這抽象的事物給描述好後，要建立一個實際的實例。</description></item><item><title>物件導向 03 - Interface</title><link>https://cch0124.github.io/code/2020-12-17-oop/</link><pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-17-oop/</guid><description>static 編寫一個類時，只有透過 new 關鍵字才會產生出物件，此時系統才會分配記憶體空間給該物件，這樣才能供外部調用。但某些特定數據在記憶體空間只有一份。台灣是個國家名稱，每一個台灣人都共享此國家名稱，不必每一個人的實例都分配一個代表國家名稱的變量。
static 修飾的變量是共享的 因為 class 只會加載一次，則 static 變量在記憶體中也只會存在一份，存在方法區的靜態域 靜態方法中，只能調用靜態的方法或屬性，非靜態方法，既可調用非靜態的方法或屬性，也可以調用靜態的方法或屬性 在靜態方法內，不能使用 this、super 關鍵字，生命週期 操作靜態屬性的方法，通常設置為 static 工具類中的方法，習慣聲名為 static 靜態變數隨著類加載而加載，因此早於物件的建立 代碼塊 用來初始類和對象 有修飾的話只能用 static 比較 靜態代碼塊 內部可以有輸出句 隨著類加載而執行，且只執行一次 初始化類的訊息 如果一個類中定義了多個靜態代碼塊，則按照宣告先後順序執行 靜態代碼塊的執行要優先於非靜態代碼塊的執行 靜態代碼塊內只調用靜態的屬性、靜態的方法，不能調用非靜態的結構 非靜態代碼塊 內部可以有輸出句 隨著物件的創見而執行 每創建一個物件，就執行一次非靜態代碼塊 可以在創建對象時，隊對象的屬性等進行初始化 如果一個類中定義了多個非靜態代碼塊，則按照宣告先後順序執行 非靜態代碼塊內只調用靜態的屬性、靜態的方法，也能調用非靜態的結構 public class Person { String name; int age; static String des = &amp;#34;Hello&amp;#34;; public Person() { } public Person(String name, int age) { this.</description></item><item><title>LeetCode 2. Add Two Numbers</title><link>https://cch0124.github.io/code/2020-12-13-addtwonumbers/</link><pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-13-addtwonumbers/</guid><description>題目 2. Add Two Numbers，單純的將兩個鏈接做相加。須注意的是進位而已。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int carry = 0; ListNode dummy = new ListNode(0); ListNode cur = dummy; int l1Val = 0; int l2Val = 0; int sum = 0; while (l1 !</description></item><item><title>LeetCode 5. Longest Palindromic Substring</title><link>https://cch0124.github.io/code/2020-12-13-longestpalindromicsubstring/</link><pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-13-longestpalindromicsubstring/</guid><description>題目 5. Longest Palindromic Substring，這題一開始沒想出來解法，但是是知道回文規則。看了影片和一些參考資料才知道使用 DP 的原理。
class Solution { public String longestPalindrome(String s) { if (s.length() == 1) return s; if (s.length() == 2 &amp;amp;&amp;amp; s.charAt(0) == s.charAt(1)){ return s; } int start = 0; int end = 0; boolean [][] dp = new boolean[s.length()][s.length()]; // 自己和自己是回文 for (int i=0; i&amp;lt;dp.length; i++){ dp[i][i] = true; } // 相鄰的字元相同也是回文 for (int i = 0; i &amp;lt; s.length()-1; i++) { if (s.</description></item><item><title>LeetCode 62. Unique Paths and 63. Unique Paths II</title><link>https://cch0124.github.io/code/2020-12-12-uniquepaths/</link><pubDate>Sat, 12 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-12-uniquepaths/</guid><description>題目 62 與 題目 63 是相似的問題，後者多了障礙物的設計。思路就是利用動態規劃，其中當前位置會是左邊與上面的能夠抵達方式的相加，因為題目限制往右和往下走。
題目 62
class Solution { public int uniquePaths(int m, int n) { int [][] dp = new int[m][n]; for(int i=0; i&amp;lt;m; i++){ for(int j=0; j&amp;lt;n; j++){ if( i == 0 || j == 0 ) { dp[i][j] = 1; } else { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } } return dp[m-1][n-1]; } } 題目 63，相較於 62 多了很多比較。我們把障礙物的當前能夠抵達次數設為 0，其做相加時不影響結果。接著起點做個判斷，非障礙物將其設為 1 以進行後續計算，在邊緣的地方有可能存在障礙物，因此不能像題目 62 一樣直接都設為 1。</description></item><item><title>LeetCode 64. Minimum Path Sum</title><link>https://cch0124.github.io/code/2020-12-12-minimumpathsum/</link><pubDate>Sat, 12 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-12-minimumpathsum/</guid><description>題目 64. Minimum Path Sum 尋找最少的路徑成本從起始點 (0,0) 到最右右下角，相似於題目 62 和 63。同樣的期限制是向右和向下。
class Solution { public int minPathSum(int[][] grid) { for(int i=0; i&amp;lt;grid.length; i++){ for(int j=0; j&amp;lt;grid[0].length; j++){ if ( i == 0 &amp;amp;&amp;amp; j == 0){ continue; } if (i == 0){ grid[i][j] = grid[i][j]+grid[i][j-1]; } else if (j == 0){ grid[i][j] = grid[i][j]+grid[i-1][j]; } else { grid[i][j] = Math.min((grid[i][j] + grid[i][j-1]), (grid[i][j] + grid[i-1][j])); } } } return grid[grid.length-1][grid[0].length-1]; } } 例子</description></item><item><title>LeetCode 1306. Jump Game III</title><link>https://cch0124.github.io/code/2020-12-10-jumpgameiii/</link><pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-10-jumpgameiii/</guid><description>題目，會給一個起始點(start)，而這個起始點可以選擇對元素進行加或減，透過這種方式不斷進行，最後檢測有沒有辦法到達值 0 的元素。
思路就是要麻當前元素進行減或加，用遞迴方式不斷去求值。使用一個 boolean 的陣列記錄當前該位置是否訪問過。
class Solution { public boolean canReach(int[] arr, int start) { boolean [] vis = new boolean[arr.length]; return canReach(arr, start, vis); } private boolean canReach(int[] arr, int start, boolean[] vis){ if (start &amp;lt; arr.length &amp;amp;&amp;amp; start &amp;gt;= 0 &amp;amp;&amp;amp; !vis[start]){ if (arr[start] == 0){ return true; } vis[start] = true; return canReach(arr, start + arr[start], vis) || canReach(arr, start - arr[start], vis); } return false; } }</description></item><item><title>783. Minimum Distance Between BST Nodes</title><link>https://cch0124.github.io/code/2020-12-09-minimumdistancebetweenbstnodes/</link><pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-09-minimumdistancebetweenbstnodes/</guid><description>題目，找出兩節點最小差值，思路以中序概念來想，經過 BST 樹經過中序遍歷後其結果會是排序的樣子，因此我們只要當前的值和左邊的值進行相減逐一比較即可獲得答案。
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int res = Integer.MAX_VALUE; TreeNode node = null; public int minDiffInBST(TreeNode root) { if (root == null) return 0; minDiffInBST(root.</description></item><item><title>897. Increasing Order Search Tree</title><link>https://cch0124.github.io/code/2020-12-09-increasingordersearchtree/</link><pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-09-increasingordersearchtree/</guid><description>題目，以中序為概念。BST 樹經過中序後其最後會是排序結果。
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { TreeNode res = new TreeNode(0); TreeNode cur = res; public TreeNode increasingBST(TreeNode root) { if (root !</description></item><item><title>LeetCode 938. Range Sum of BST</title><link>https://cch0124.github.io/code/2020-12-09-rangesumofbst/</link><pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-09-rangesumofbst/</guid><description>題目，這一題會給 low 和 high，只要這棵樹的節點數值滿足大於等於 low 和小於等於 high 就將其相加並成為最後結果。思路是使用前序進行遍歷，並利用 BST 特性左小右大來決定下個節點是否要進行遞歸。
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int res = 0; public int rangeSumBST(TreeNode root, int low, int high) { if (root !</description></item><item><title>LeetCode 53. Maximum Subarray</title><link>https://cch0124.github.io/code/2020-12-08-maximumsubarray/</link><pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate><guid>https://cch0124.github.io/code/2020-12-08-maximumsubarray/</guid><description>題目，求連續最大子序列。這題配合著此youtube實作。透過各個擊破方式，增加程式運行效率。同時在進行切分時，有三種方案
左邊最大 右邊最大 中間往左和往右 其第三種會有同時跨佐和跨右問題，其解決辦法如下
class Solution { public int maxSubArray(int[] nums) { return maxSubArray(nums, 0, nums.length-1); } /** * case 1. left Max * case 2. right Max * case 3. mid Max **/ public int maxSubArray(int[] nums, int start, int end){ if(start == end){ return nums[start]; } int mid = (start + end)/2; return Math.max( Math.max(maxSubArray(nums, start, mid), maxSubArray(nums, mid+1, end)), MaxSubCrossArray(nums, start, mid, end) ); } /** * 中間往左和往右計算連續最大值，最後在與往左和往右相加進行比較 **/ public int MaxSubCrossArray(int[] nums, int start, int mid, int end){ int sum = 0; int left_sum = Integer.</description></item></channel></rss>